================================================================================
PROJET : C:\AndroidStudioProjects\RemoteCam-Enhanced\app\src\main
DATE   : 01/17/2026 20:56:11
================================================================================

RÉSUMÉ :
----------------------------------------
Dossiers scannés (approx) : 31
Fichiers texte trouvés    : 38

ARBORESCENCE :
----------------------------------------
.
├── [java]
│   └── [com]
│       └── [samsung]
│           └── [android]
│               └── [scan3d]
│                   ├── [fragments]
│                   │   ├── CameraSettingsScreen.kt
│                   │   └── SettingsComposables.kt
│                   ├── [http]
│                   │   └── HttpService.kt
│                   ├── [screens]
│                   │   ├── AdditionalSettingsScreen.kt
│                   │   ├── CameraScreen.kt
│                   │   ├── CameraScreenUI.kt
│                   │   ├── PermissionScreen.kt
│                   │   ├── PermissionScreenUI.kt
│                   │   ├── PowerSettingsScreen.kt
│                   │   └── SettingsScreen.kt
│                   ├── [serv]
│                   │   ├── Cam.kt
│                   │   └── CamEngine.kt
│                   ├── [ui]
│                   │   └── [theme]
│                   │       └── Theme.kt
│                   ├── [util]
│                   │   ├── ClipboardUtil.kt
│                   │   ├── IpUtil.kt
│                   │   ├── Selector.kt
│                   │   └── SettingsManager.kt
│                   ├── AppNavigation.kt
│                   ├── CameraActivity.kt
│                   └── CameraState.kt
├── [res]
│   ├── [anim]
│   │   ├── nav_default_enter_anim.xml
│   │   ├── nav_default_exit_anim.xml
│   │   ├── nav_default_pop_enter_anim.xml
│   │   └── nav_default_pop_exit_anim.xml
│   ├── [drawable]
│   │   ├── ic_launcher_background.xml
│   │   ├── ic_launcher_monochrome.xml
│   │   └── ic_photo.xml
│   ├── [drawable-hdpi]
│   │   ├── ic_close.png
│   │   ├── ic_launcher.png
│   │   └── ic_linked_camera.png
│   ├── [drawable-mdpi]
│   │   ├── ic_close.png
│   │   ├── ic_launcher.png
│   │   └── ic_linked_camera.png
│   ├── [drawable-xhdpi]
│   │   ├── ic_close.png
│   │   ├── ic_launcher.png
│   │   └── ic_linked_camera.png
│   ├── [drawable-xxhdpi]
│   │   ├── ic_close.png
│   │   ├── ic_launcher.png
│   │   └── ic_linked_camera.png
│   ├── [drawable-xxxhdpi]
│   │   ├── ic_close.png
│   │   └── ic_linked_camera.png
│   ├── [mipmap-anydpi-v26]
│   │   ├── ic_launcher.xml
│   │   └── ic_launcher_round.xml
│   ├── [mipmap-hdpi]
│   │   ├── ic_launcher.webp
│   │   ├── ic_launcher_foreground.webp
│   │   └── ic_launcher_round.webp
│   ├── [mipmap-mdpi]
│   │   ├── ic_launcher.webp
│   │   ├── ic_launcher_foreground.webp
│   │   └── ic_launcher_round.webp
│   ├── [mipmap-xhdpi]
│   │   ├── ic_launcher.webp
│   │   ├── ic_launcher_foreground.webp
│   │   └── ic_launcher_round.webp
│   ├── [mipmap-xxhdpi]
│   │   ├── ic_launcher.webp
│   │   ├── ic_launcher_foreground.webp
│   │   └── ic_launcher_round.webp
│   ├── [mipmap-xxxhdpi]
│   │   ├── ic_launcher.webp
│   │   ├── ic_launcher_foreground.webp
│   │   └── ic_launcher_round.webp
│   ├── [values]
│   │   ├── ic_launcher_background.xml
│   │   ├── strings.xml
│   │   └── styles.xml
│   ├── [values-fr]
│   │   └── strings.xml
│   ├── [values-hu]
│   │   └── strings.xml
│   ├── [values-pt-rBR]
│   │   └── strings.xml
│   └── [xml]
│       ├── backup_rules.xml
│       └── data_extraction_rules.xml
├── AndroidManifest.xml
└── ic_launcher-playstore.png

CONTENU DES FICHIERS :
----------------------------------------
================================================================================
FICHIER : \AndroidStudioProjects\RemoteCam-Enhanced\app\src\main\java\com\samsung\android\scan3d\fragments\CameraSettingsScreen.kt
================================================================================
    package com.samsung.android.scan3d.fragments
    
    import androidx.compose.foundation.layout.Arrangement
    import androidx.compose.foundation.layout.Column
    import androidx.compose.foundation.layout.fillMaxSize
    import androidx.compose.foundation.layout.padding
    import androidx.compose.foundation.rememberScrollState
    import androidx.compose.foundation.verticalScroll
    import androidx.compose.material.icons.Icons
    import androidx.compose.material.icons.automirrored.filled.ArrowBack
    import androidx.compose.material.icons.automirrored.rounded.VolumeUp
    import androidx.compose.material.icons.rounded.Block
    import androidx.compose.material.icons.rounded.FilterCenterFocus
    import androidx.compose.material.icons.rounded.Grain
    import androidx.compose.material.icons.rounded.Memory
    import androidx.compose.material.icons.rounded.Movie
    import androidx.compose.material.icons.rounded.Speed
    import androidx.compose.material.icons.rounded.TouchApp
    import androidx.compose.material3.ExperimentalMaterial3Api
    import androidx.compose.material3.HorizontalDivider
    import androidx.compose.material3.Icon
    import androidx.compose.material3.MaterialTheme
    import androidx.compose.material3.Scaffold
    import androidx.compose.material3.Text
    import androidx.compose.material3.TopAppBar
    import androidx.compose.material3.TopAppBarDefaults
    import androidx.compose.runtime.Composable
    import androidx.compose.runtime.getValue
    import androidx.compose.runtime.mutableIntStateOf
    import androidx.compose.runtime.mutableStateOf
    import androidx.compose.runtime.remember
    import androidx.compose.runtime.setValue
    import androidx.compose.ui.Modifier
    import androidx.compose.ui.platform.LocalContext
    import androidx.compose.ui.res.stringResource
    import androidx.compose.ui.unit.dp
    import com.samsung.android.scan3d.R
    import com.samsung.android.scan3d.util.SettingsManager
    import androidx.compose.ui.text.font.FontWeight
    import androidx.compose.material3.FilledTonalIconButton
    import androidx.compose.material3.IconButtonDefaults
    
    @OptIn(ExperimentalMaterial3Api::class)
    @Composable
    fun CameraSettingsScreen(
        onBackClicked: () -> Unit,
        onSendFpsIntent: (Int) -> Unit,
        onSendAntiFlickerIntent: (Int) -> Unit,
        onSendNoiseReductionIntent: (Int) -> Unit,
        onSendStabilizationIntent: (Boolean) -> Unit,
        onSendZoomSmoothingIntent: (Int) -> Unit
    ) {
        val context = LocalContext.current
    
        var showRememberDialog by remember { mutableStateOf(false) }
        val dismissRememberDialog = { showRememberDialog = false }
        var showFpsDialog by remember { mutableStateOf(false) }
        val dismissFpsDialog = { showFpsDialog = false }
        var showDoubleTapDialog by remember { mutableStateOf(false) }
        val dismissDoubleTapDialog = { showDoubleTapDialog = false }
        var showFlickerDialog by remember { mutableStateOf(false) }
        val dismissFlickerDialog = { showFlickerDialog = false }
        var showNoiseReductionDialog by remember { mutableStateOf(false) }
        val dismissNoiseReductionDialog = { showNoiseReductionDialog = false }
        var showVolumeActionDialog by remember { mutableStateOf(false) }
        val dismissVolumeActionDialog = { showVolumeActionDialog = false }
        var showZoomSmoothingDialog by remember { mutableStateOf(false) }
        val dismissZoomSmoothingDialog = { showZoomSmoothingDialog = false }
    
        var currentSmoothingDelay by remember { mutableIntStateOf(SettingsManager.loadZoomSmoothingDelay(context)) }
        var rememberSettingsEnabled by remember { mutableStateOf(SettingsManager.loadRememberSettings(context)) }
        var rememberFlash by remember { mutableStateOf(SettingsManager.loadRememberFlash(context)) }
        var rememberZoom by remember { mutableStateOf(SettingsManager.loadRememberZoom(context)) }
        var rememberSensor by remember { mutableStateOf(SettingsManager.loadRememberSensor(context)) }
        var rememberResolution by remember { mutableStateOf(SettingsManager.loadRememberResolution(context)) }
        var rememberQuality by remember { mutableStateOf(SettingsManager.loadRememberQuality(context)) }
        var currentFps by remember { mutableIntStateOf(SettingsManager.loadTargetFps(context)) }
        var currentDoubleTap by remember { mutableIntStateOf(SettingsManager.loadDoubleTapAction(context)) }
        var stabilizationOff by remember { mutableStateOf(SettingsManager.loadStabilizationOff(context)) }
        var currentFlicker by remember { mutableIntStateOf(SettingsManager.loadAntiFlickerMode(context)) }
        var currentNoiseReduction by remember { mutableIntStateOf(SettingsManager.loadNoiseReductionMode(context)) }
        var currentVolumeAction by remember { mutableIntStateOf(SettingsManager.loadVolumeAction(context)) }
    
        Scaffold(
            topBar = {
                TopAppBar(
                    title = { Text(stringResource(R.string.settings_camera_title), fontWeight = FontWeight.Bold) },
                    navigationIcon = {
                        FilledTonalIconButton(
                            onClick = onBackClicked,
                            colors = IconButtonDefaults.filledTonalIconButtonColors(
                                containerColor = MaterialTheme.colorScheme.surfaceContainer,
                                contentColor = MaterialTheme.colorScheme.onSurfaceVariant
                            )
                        ) {
                            Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = stringResource(R.string.settings_back))
                        }
                    },
                    colors = TopAppBarDefaults.topAppBarColors(
                        containerColor = MaterialTheme.colorScheme.background
                    )
                )
            }
        ) { padding ->
            Column(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(padding)
                    .verticalScroll(rememberScrollState())
                    .padding(16.dp),
                verticalArrangement = Arrangement.spacedBy(16.dp)
            ) {
                SettingsGroup(title = stringResource(R.string.settings_camera_title)) {
                    SettingsClickableToggleRow(
                        text = stringResource(R.string.settings_remember_title),
                        summary = stringResource(R.string.settings_remember_desc),
                        icon = Icons.Rounded.Memory,
                        checked = rememberSettingsEnabled,
                        onCheckedChange = {
                            rememberSettingsEnabled = it
                            SettingsManager.saveRememberSettings(context, it)
                            if (it) {
                                rememberFlash = true
                                SettingsManager.saveRememberFlash(context, true)
                                rememberZoom = true
                                SettingsManager.saveRememberZoom(context, true)
                                rememberSensor = true
                                SettingsManager.saveRememberSensor(context, true)
                                rememberResolution = true
                                SettingsManager.saveRememberResolution(context, true)
                                rememberQuality = true
                                SettingsManager.saveRememberQuality(context, true)
                            }
                        },
                        onClick = { showRememberDialog = true }
                    )
    
                    HorizontalDivider(modifier = Modifier.padding(vertical = 8.dp))
    
                    val fpsSummary = "$currentFps FPS"
                    SettingsClickableRow(
                        text = stringResource(R.string.settings_fps_title),
                        icon = Icons.Rounded.Speed,
                        summary = fpsSummary,
                        onClick = { showFpsDialog = true }
                    )
    
                    HorizontalDivider(modifier = Modifier.padding(vertical = 8.dp))
    
                    val doubleTapSummary = when (currentDoubleTap) {
                        SettingsManager.DOUBLE_TAP_SWITCH_CAM -> stringResource(R.string.settings_double_tap_switch_cam)
                        SettingsManager.DOUBLE_TAP_TOGGLE_ZOOM -> stringResource(R.string.settings_double_tap_toggle_zoom)
                        else -> stringResource(R.string.settings_double_tap_off)
                    }
                    SettingsClickableRow(
                        text = stringResource(R.string.settings_double_tap_title),
                        icon = Icons.Rounded.TouchApp,
                        summary = doubleTapSummary,
                        onClick = { showDoubleTapDialog = true }
                    )
    
                    HorizontalDivider(modifier = Modifier.padding(vertical = 8.dp))
    
                    SettingsToggleRow(
                        text = stringResource(R.string.settings_stabilization_title),
                        icon = Icons.Rounded.FilterCenterFocus,
                        checked = stabilizationOff,
                        onCheckedChange = {
                            stabilizationOff = it
                            SettingsManager.saveStabilizationOff(context, it)
                            onSendStabilizationIntent(it)
                        }
                    )
    
                    HorizontalDivider(modifier = Modifier.padding(vertical = 8.dp))
    
                    val flickerSummary = when (currentFlicker) {
                        SettingsManager.ANTI_FLICKER_50HZ -> stringResource(R.string.settings_flicker_50hz)
                        SettingsManager.ANTI_FLICKER_60HZ -> stringResource(R.string.settings_flicker_60hz)
                        SettingsManager.ANTI_FLICKER_OFF -> stringResource(R.string.settings_flicker_off)
                        else -> stringResource(R.string.settings_flicker_auto)
                    }
                    SettingsClickableRow(
                        text = stringResource(R.string.settings_flicker_title),
                        icon = Icons.Rounded.Block,
                        summary = flickerSummary,
                        onClick = { showFlickerDialog = true }
                    )
    
                    HorizontalDivider(modifier = Modifier.padding(vertical = 8.dp))
    
                    val noiseReductionSummary = when (currentNoiseReduction) {
                        SettingsManager.NR_OFF -> stringResource(R.string.settings_noise_reduction_off)
                        SettingsManager.NR_LOW -> stringResource(R.string.settings_noise_reduction_low)
                        SettingsManager.NR_HIGH -> stringResource(R.string.settings_noise_reduction_high)
                        else -> stringResource(R.string.settings_noise_reduction_auto)
                    }
                    SettingsClickableRow(
                        text = stringResource(R.string.settings_noise_reduction_title),
                        icon = Icons.Rounded.Grain,
                        summary = noiseReductionSummary,
                        onClick = { showNoiseReductionDialog = true }
                    )
                }
    
                SettingsGroup(title = stringResource(R.string.settings_controls_title)) {
                    val volumeSummary = when (currentVolumeAction) {
                        SettingsManager.VOL_ACTION_ZOOM -> stringResource(R.string.settings_volume_action_zoom)
                        SettingsManager.VOL_ACTION_SWITCH_CAM -> stringResource(R.string.settings_volume_action_switch_cam)
                        SettingsManager.VOL_ACTION_TOGGLE_FLASH -> stringResource(R.string.settings_volume_action_toggle_flash)
                        else -> stringResource(R.string.settings_volume_action_off)
                    }
                    SettingsClickableRow(
                        text = stringResource(R.string.settings_volume_action_title),
                        icon = Icons.AutoMirrored.Rounded.VolumeUp,
                        summary = volumeSummary,
                        onClick = { showVolumeActionDialog = true }
                    )
                }
    
                SettingsGroup(title = stringResource(R.string.settings_remote_control_title)) {
                    val smoothingSummary = if (currentSmoothingDelay == 0) {
                        stringResource(R.string.settings_zoom_smoothing_none)
                    } else {
                        "$currentSmoothingDelay ms"
                    }
                    SettingsClickableRow(
                        text = stringResource(R.string.settings_zoom_smoothing_title),
                        summary = stringResource(R.string.settings_zoom_smoothing_desc),
                        icon = Icons.Rounded.Movie,
                        subSummary = smoothingSummary,
                        onClick = { showZoomSmoothingDialog = true }
                    )
                }
            }
        }
    
        if (showRememberDialog) {
            RememberSettingsDialog(
                rememberFlash = rememberFlash,
                rememberZoom = rememberZoom,
                rememberSensor = rememberSensor,
                rememberResolution = rememberResolution,
                rememberQuality = rememberQuality,
                onDismiss = dismissRememberDialog,
                onSave = { newFlash, newZoom, newSensor, newRes, newQuality ->
                    rememberFlash = newFlash
                    SettingsManager.saveRememberFlash(context, rememberFlash)
                    rememberZoom = newZoom
                    SettingsManager.saveRememberZoom(context, rememberZoom)
                    rememberSensor = newSensor
                    SettingsManager.saveRememberSensor(context, rememberSensor)
                    rememberResolution = newRes
                    SettingsManager.saveRememberResolution(context, rememberResolution)
                    rememberQuality = newQuality
                    SettingsManager.saveRememberQuality(context, rememberQuality)
                    dismissRememberDialog()
                }
            )
        }
    
        if (showFpsDialog) {
            TargetFpsDialog(
                currentFps = currentFps,
                onDismiss = dismissFpsDialog,
                onFpsSelected = { newFps ->
                    currentFps = newFps
                    SettingsManager.saveTargetFps(context, newFps)
                    onSendFpsIntent(newFps)
                    dismissFpsDialog()
                }
            )
        }
    
        if (showDoubleTapDialog) {
            DoubleTapDialog(
                currentAction = currentDoubleTap,
                onDismiss = dismissDoubleTapDialog,
                onActionSelected = { newAction ->
                    currentDoubleTap = newAction
                    SettingsManager.saveDoubleTapAction(context, newAction)
                    dismissDoubleTapDialog()
                }
            )
        }
    
        if (showFlickerDialog) {
            AntiFlickerDialog(
                currentMode = currentFlicker,
                onDismiss = dismissFlickerDialog,
                onModeSelected = { newMode ->
                    currentFlicker = newMode
                    SettingsManager.saveAntiFlickerMode(context, newMode)
                    onSendAntiFlickerIntent(newMode)
                    dismissFlickerDialog()
                }
            )
        }
    
        if (showNoiseReductionDialog) {
            NoiseReductionDialog(
                currentMode = currentNoiseReduction,
                onDismiss = dismissNoiseReductionDialog,
                onModeSelected = { newMode ->
                    currentNoiseReduction = newMode
                    SettingsManager.saveNoiseReductionMode(context, newMode)
                    onSendNoiseReductionIntent(newMode)
                    dismissNoiseReductionDialog()
                }
            )
        }
    
        if (showVolumeActionDialog) {
            VolumeActionDialog(
                currentAction = currentVolumeAction,
                onDismiss = dismissVolumeActionDialog,
                onActionSelected = { newAction ->
                    currentVolumeAction = newAction
                    SettingsManager.saveVolumeAction(context, newAction)
                    dismissVolumeActionDialog()
                }
            )
        }
    
        if (showZoomSmoothingDialog) {
            ZoomSmoothingDialog(
                currentDelay = currentSmoothingDelay,
                onDismiss = dismissZoomSmoothingDialog,
                onDelaySelected = { newDelay ->
                    currentSmoothingDelay = newDelay
                    SettingsManager.saveZoomSmoothingDelay(context, newDelay)
                    onSendZoomSmoothingIntent(newDelay)
                    dismissZoomSmoothingDialog()
                }
            )
        }
    }
    


================================================================================
FICHIER : \AndroidStudioProjects\RemoteCam-Enhanced\app\src\main\java\com\samsung\android\scan3d\fragments\SettingsComposables.kt
================================================================================
    package com.samsung.android.scan3d.fragments
    
    import androidx.compose.foundation.clickable
    import androidx.compose.foundation.layout.Arrangement
    import androidx.compose.foundation.layout.Column
    import androidx.compose.foundation.layout.ColumnScope
    import androidx.compose.foundation.layout.Row
    import androidx.compose.foundation.layout.Spacer
    import androidx.compose.foundation.layout.fillMaxWidth
    import androidx.compose.foundation.layout.height
    import androidx.compose.foundation.layout.padding
    import androidx.compose.foundation.layout.size
    import androidx.compose.foundation.rememberScrollState
    import androidx.compose.foundation.selection.selectable
    import androidx.compose.foundation.shape.RoundedCornerShape
    import androidx.compose.foundation.verticalScroll
    import androidx.compose.material.icons.Icons
    import androidx.compose.material.icons.filled.Check
    import androidx.compose.material.icons.filled.Close
    import androidx.compose.material.icons.filled.Star
    import androidx.compose.material.icons.rounded.Block
    import androidx.compose.material.icons.rounded.CameraAlt
    import androidx.compose.material.icons.rounded.FlashOn
    import androidx.compose.material.icons.rounded.Grain
    import androidx.compose.material.icons.rounded.HighQuality
    import androidx.compose.material.icons.rounded.Language
    import androidx.compose.material.icons.rounded.Memory
    import androidx.compose.material.icons.rounded.PhotoSizeSelectActual
    import androidx.compose.material.icons.rounded.Speed
    import androidx.compose.material.icons.rounded.Sync
    import androidx.compose.material.icons.rounded.TouchApp
    import androidx.compose.material.icons.rounded.ZoomIn
    import androidx.compose.material3.AlertDialog
    import androidx.compose.material3.Button
    import androidx.compose.material3.Card
    import androidx.compose.material3.CardDefaults
    import androidx.compose.material3.Checkbox
    import androidx.compose.material3.ExperimentalMaterial3Api
    import androidx.compose.material3.Icon
    import androidx.compose.material3.MaterialTheme
    import androidx.compose.material3.RadioButton
    import androidx.compose.material3.Switch
    import androidx.compose.material3.SwitchDefaults
    import androidx.compose.material3.Text
    import androidx.compose.material3.TextButton
    import androidx.compose.runtime.Composable
    import androidx.compose.runtime.getValue
    import androidx.compose.runtime.mutableIntStateOf
    import androidx.compose.runtime.mutableStateOf
    import androidx.compose.runtime.remember
    import androidx.compose.runtime.setValue
    import androidx.compose.ui.Alignment
    import androidx.compose.ui.Modifier
    import androidx.compose.ui.draw.clip
    import androidx.compose.ui.graphics.vector.ImageVector
    import androidx.compose.ui.platform.LocalContext
    import androidx.compose.ui.platform.LocalUriHandler
    import androidx.compose.ui.res.stringResource
    import androidx.compose.ui.semantics.Role
    import androidx.compose.ui.text.font.FontWeight
    import androidx.compose.ui.text.style.TextAlign
    import androidx.compose.ui.unit.dp
    import com.samsung.android.scan3d.R
    import com.samsung.android.scan3d.util.SettingsManager
    import androidx.compose.material.icons.rounded.Movie
    import androidx.compose.foundation.text.KeyboardOptions
    import androidx.compose.material.icons.rounded.SettingsEthernet
    import androidx.compose.material3.TextField
    import androidx.compose.runtime.saveable.rememberSaveable
    import androidx.compose.ui.text.input.KeyboardType
    import androidx.compose.material.icons.rounded.EditNote
    
    
    @Composable
    fun SettingsGroup(title: String, content: @Composable ColumnScope.() -> Unit) {
        Card(
            shape = RoundedCornerShape(16.dp),
            colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceContainerLowest),
            modifier = Modifier.fillMaxWidth()
        ) {
            Column(modifier = Modifier.padding(16.dp)) {
                Text(
                    text = title,
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Bold,
                    color = MaterialTheme.colorScheme.primary,
                    modifier = Modifier.padding(bottom = 12.dp)
                )
                Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {
                    content()
                }
            }
        }
    }
    @Composable
    fun ThemeOptionRow(text: String, icon: ImageVector, selected: Boolean, onClick: () -> Unit) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .clip(RoundedCornerShape(8.dp))
                .selectable(
                    selected = selected,
                    onClick = onClick,
                    role = Role.RadioButton
                )
                .padding(vertical = 8.dp, horizontal = 4.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Icon(icon, contentDescription = text, modifier = Modifier.padding(end = 16.dp), tint = MaterialTheme.colorScheme.onSurfaceVariant)
            Text(text, modifier = Modifier.weight(1f), style = MaterialTheme.typography.bodyLarge)
            RadioButton(selected = selected, onClick = null)
        }
    }
    @Composable
    fun SettingsToggleRow(
        text: String,
        icon: ImageVector,
        checked: Boolean,
        onCheckedChange: (Boolean) -> Unit
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .clickable { onCheckedChange(!checked) }
                .clip(RoundedCornerShape(8.dp))
                .padding(vertical = 8.dp, horizontal = 4.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Icon(icon, contentDescription = text, modifier = Modifier.padding(end = 16.dp), tint = MaterialTheme.colorScheme.onSurfaceVariant)
            Text(text, modifier = Modifier.weight(1f), style = MaterialTheme.typography.bodyLarge)
    
            AnimatedSystemSwitch(checked = checked, onCheckedChange = onCheckedChange)
        }
    }
    
    @Composable
    fun SettingsClickableToggleRow(
        text: String,
        summary: String,
        icon: ImageVector,
        checked: Boolean,
        onCheckedChange: (Boolean) -> Unit,
        onClick: () -> Unit
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .clickable(onClick = onClick)
                .clip(RoundedCornerShape(8.dp))
                .padding(vertical = 8.dp, horizontal = 4.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Icon(icon, contentDescription = text, modifier = Modifier.padding(end = 16.dp), tint = MaterialTheme.colorScheme.onSurfaceVariant)
            Column(modifier = Modifier.weight(1f)) {
                Text(text, style = MaterialTheme.typography.bodyLarge)
                Text(
                    text = summary,
                    style = MaterialTheme.typography.bodyMedium,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
            AnimatedSystemSwitch(checked = checked, onCheckedChange = onCheckedChange)
        }
    }
    @Composable
    fun SettingsClickableRow(
        text: String,
        icon: ImageVector,
        summary: String? = null,
        subSummary: String? = null,
        onClick: () -> Unit
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .clickable(onClick = onClick)
                .clip(RoundedCornerShape(8.dp))
                .padding(vertical = 12.dp, horizontal = 4.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Icon(icon, contentDescription = text, modifier = Modifier.padding(end = 16.dp), tint = MaterialTheme.colorScheme.onSurfaceVariant)
            Column(modifier = Modifier.weight(1f)) {
                Text(text, style = MaterialTheme.typography.bodyLarge)
                if (summary != null) {
                    Text(
                        text = summary,
                        style = MaterialTheme.typography.bodyMedium,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                }
            }
            if (subSummary != null) {
                Text(
                    text = subSummary,
                    style = MaterialTheme.typography.bodyMedium,
                    color = MaterialTheme.colorScheme.onSurfaceVariant,
                    modifier = Modifier.padding(start = 8.dp)
                )
            }
        }
    }
    @Composable
    fun CheckboxRow(
        text: String,
        icon: ImageVector,
        checked: Boolean,
        onCheckedChange: (Boolean) -> Unit,
        enabled: Boolean = true
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .clip(RoundedCornerShape(8.dp))
                .clickable(enabled = enabled) { onCheckedChange(!checked) }
                .padding(vertical = 8.dp, horizontal = 4.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Icon(
                imageVector = icon,
                contentDescription = text,
                modifier = Modifier.padding(end = 16.dp),
                tint = if (enabled) MaterialTheme.colorScheme.onSurfaceVariant else MaterialTheme.colorScheme.outline
            )
            Text(
                text = text,
                modifier = Modifier.weight(1f),
                style = MaterialTheme.typography.bodyLarge,
                color = if (enabled) MaterialTheme.colorScheme.onSurface else MaterialTheme.colorScheme.outline
            )
            Checkbox(
                checked = checked,
                onCheckedChange = onCheckedChange,
                enabled = enabled
            )
        }
    }
    
    @Composable
    fun AnimatedSystemSwitch(
        checked: Boolean,
        onCheckedChange: (Boolean) -> Unit,
        modifier: Modifier = Modifier
    ) {
        val checkedThumbColor = MaterialTheme.colorScheme.onPrimary
        val checkedTrackColor = MaterialTheme.colorScheme.primary
        val checkedIconTint = MaterialTheme.colorScheme.primary
    
        val uncheckedThumbColor = MaterialTheme.colorScheme.outline
        val uncheckedTrackColor = MaterialTheme.colorScheme.surfaceVariant
        val uncheckedIconTint = MaterialTheme.colorScheme.onSurfaceVariant
    
        Switch(
            checked = checked,
            onCheckedChange = onCheckedChange,
            modifier = modifier,
            thumbContent = {
                Icon(
                    imageVector = if (checked) Icons.Filled.Check else Icons.Filled.Close,
                    contentDescription = null,
                    modifier = Modifier.size(SwitchDefaults.IconSize),
                    tint = if (checked) checkedIconTint else uncheckedIconTint
                )
            },
            colors = SwitchDefaults.colors(
                checkedThumbColor = checkedThumbColor,
                checkedTrackColor = checkedTrackColor,
    
                uncheckedThumbColor = uncheckedThumbColor,
                uncheckedTrackColor = uncheckedTrackColor
            )
        )
    }
    
    @OptIn(ExperimentalMaterial3Api::class)
    @Composable
    fun AboutDialog(onDismiss: () -> Unit) {
        val uriHandler = LocalUriHandler.current
        val githubRepoUrl = "https://github.com/alan7383/RemoteCam-Enhanced"
    
        val context = LocalContext.current
        var clickCount by remember { mutableIntStateOf(0) }
        var showEasterEgg by remember { mutableStateOf(false) }
    
        val versionName = try {
            context.packageManager.getPackageInfo(context.packageName, 0).versionName
        } catch (_: Exception) {
            "?.?.?"
        }
    
        AlertDialog(
            onDismissRequest = onDismiss,
            confirmButton = {
                TextButton(onClick = onDismiss) {
                    Text(stringResource(R.string.settings_close))
                }
            },
            title = { Text(stringResource(R.string.settings_about_title)) },
            icon = { Icon(Icons.Rounded.Sync, contentDescription = null) },
            text = {
                Column(verticalArrangement = Arrangement.spacedBy(16.dp)) {
                    Text(
                        text = stringResource(R.string.about_fork),
                        style = MaterialTheme.typography.bodyMedium,
                        textAlign = TextAlign.Center,
                        modifier = Modifier.fillMaxWidth()
                    )
    
                    Button(
                        onClick = { uriHandler.openUri(githubRepoUrl) },
                        modifier = Modifier.fillMaxWidth()
                    ) {
                        Icon(Icons.Default.Star, contentDescription = null, modifier = Modifier.size(18.dp))
                        Spacer(Modifier.size(8.dp))
                        Text(stringResource(R.string.about_star))
                    }
    
                    Text(
                        text = stringResource(R.string.about_telegram),
                        style = MaterialTheme.typography.bodySmall,
                        textAlign = TextAlign.Center,
                        modifier = Modifier.fillMaxWidth()
                    )
    
                    Spacer(Modifier.height(8.dp))
    
                    Text(
                        text = stringResource(R.string.about_version, versionName ?: ""),
                        style = MaterialTheme.typography.bodySmall,
                        textAlign = TextAlign.Center,
                        color = MaterialTheme.colorScheme.onSurfaceVariant,
                        modifier = Modifier
                            .fillMaxWidth()
                            .clip(RoundedCornerShape(4.dp))
                            .clickable {
                                clickCount++
                                if (clickCount >= 7) {
                                    showEasterEgg = true
                                    clickCount = 0
                                }
                            }
                    )
    
                }
            },
            shape = RoundedCornerShape(28.dp)
        )
    
        if (showEasterEgg) {
            EasterEggDialog(onDismiss = { showEasterEgg = false })
        }
    }
    @OptIn(ExperimentalMaterial3Api::class)
    @Composable
    fun EasterEggDialog(onDismiss: () -> Unit) {
    
        AlertDialog(
            onDismissRequest = onDismiss,
            confirmButton = {
                TextButton(onClick = onDismiss) {
                    Text(stringResource(R.string.egg_button_alan))
                }
            },
            icon = { Icon(Icons.Rounded.EditNote, contentDescription = null) },
            title = { Text(stringResource(R.string.egg_title_alan)) },
            text = {
                Text(
                    text = stringResource(R.string.egg_message_alan),
                    style = MaterialTheme.typography.bodyMedium
                )
            },
            shape = RoundedCornerShape(28.dp)
        )
    }
    @OptIn(ExperimentalMaterial3Api::class)
    @Composable
    fun LanguageDialog(
        currentLanguage: String,
        onDismiss: () -> Unit,
        onLanguageSelected: (String) -> Unit
    ) {
        val languages = listOf(
            SettingsManager.LANG_AUTO to stringResource(R.string.settings_lang_auto),
            SettingsManager.LANG_EN to stringResource(R.string.settings_lang_en),
            SettingsManager.LANG_FR to stringResource(R.string.settings_lang_fr),
            SettingsManager.LANG_HU to stringResource(R.string.settings_lang_hu),
            SettingsManager.LANG_PT to stringResource(R.string.settings_lang_pt_br)
        )
    
        AlertDialog(
            onDismissRequest = onDismiss,
            icon = { Icon(Icons.Rounded.Language, contentDescription = null) },
            title = { Text(stringResource(R.string.settings_language)) },
            text = {
                Column(Modifier.verticalScroll(rememberScrollState())) {
                    languages.forEach { (langCode, langName) ->
                        DialogRadioRow(
                            text = langName,
                            selected = (currentLanguage == langCode),
                            onClick = { onLanguageSelected(langCode) }
                        )
                    }
                }
            },
            confirmButton = {
                TextButton(onClick = onDismiss) {
                    Text(stringResource(R.string.settings_close))
                }
            }
        )
    }
    @OptIn(ExperimentalMaterial3Api::class)
    @Composable
    fun RememberSettingsDialog(
        rememberFlash: Boolean,
        rememberZoom: Boolean,
        rememberSensor: Boolean,
        rememberResolution: Boolean,
        rememberQuality: Boolean,
        onDismiss: () -> Unit,
        onSave: (Boolean, Boolean, Boolean, Boolean, Boolean) -> Unit
    ) {
        var tempRememberFlash by remember { mutableStateOf(rememberFlash) }
        var tempRememberZoom by remember { mutableStateOf(rememberZoom) }
        var tempRememberSensor by remember { mutableStateOf(rememberSensor) }
        var tempRememberResolution by remember { mutableStateOf(rememberResolution) }
        var tempRememberQuality by remember { mutableStateOf(rememberQuality) }
    
        AlertDialog(
            onDismissRequest = onDismiss,
            icon = { Icon(Icons.Rounded.Memory, contentDescription = null) },
            title = { Text(stringResource(R.string.settings_remember_dialog_title)) },
            text = {
                Column(Modifier.verticalScroll(rememberScrollState())) {
                    CheckboxRow(
                        text = stringResource(R.string.settings_remember_sensor),
                        icon = Icons.Rounded.CameraAlt,
                        checked = tempRememberSensor,
                        onCheckedChange = { tempRememberSensor = it }
                    )
                    CheckboxRow(
                        text = stringResource(R.string.settings_remember_resolution),
                        icon = Icons.Rounded.PhotoSizeSelectActual,
                        checked = tempRememberResolution,
                        onCheckedChange = { tempRememberResolution = it }
                    )
                    CheckboxRow(
                        text = stringResource(R.string.settings_remember_quality),
                        icon = Icons.Rounded.HighQuality,
                        checked = tempRememberQuality,
                        onCheckedChange = { tempRememberQuality = it }
                    )
                    CheckboxRow(
                        text = stringResource(R.string.settings_remember_flash),
                        icon = Icons.Rounded.FlashOn,
                        checked = tempRememberFlash,
                        onCheckedChange = { tempRememberFlash = it }
                    )
                    CheckboxRow(
                        text = stringResource(R.string.settings_remember_zoom),
                        icon = Icons.Rounded.ZoomIn,
                        checked = tempRememberZoom,
                        onCheckedChange = { tempRememberZoom = it }
                    )
                }
            },
            confirmButton = {
                TextButton(onClick = {
                    onSave(
                        tempRememberFlash,
                        tempRememberZoom,
                        tempRememberSensor,
                        tempRememberResolution,
                        tempRememberQuality
                    )
                }) {
                    Text(stringResource(R.string.settings_save))
                }
            },
            dismissButton = {
                TextButton(onClick = onDismiss) {
                    Text(stringResource(R.string.settings_close))
                }
            }
        )
    }
    @OptIn(ExperimentalMaterial3Api::class)
    @Composable
    fun TargetFpsDialog(
        currentFps: Int,
        onDismiss: () -> Unit,
        onFpsSelected: (Int) -> Unit
    ) {
        val fpsOptions = listOf(15, 24, 30, 60)
    
        AlertDialog(
            onDismissRequest = onDismiss,
            icon = { Icon(Icons.Rounded.Speed, contentDescription = null) },
            title = { Text(stringResource(R.string.settings_fps_title)) },
            text = {
                Column(Modifier.verticalScroll(rememberScrollState())) {
                    fpsOptions.forEach { fps ->
                        DialogRadioRow(
                            text = "$fps FPS",
                            selected = (currentFps == fps),
                            onClick = { onFpsSelected(fps) }
                        )
                    }
                }
            },
            confirmButton = {
                TextButton(onClick = onDismiss) {
                    Text(stringResource(R.string.settings_close))
                }
            }
        )
    }
    @OptIn(ExperimentalMaterial3Api::class)
    @Composable
    fun DoubleTapDialog(
        currentAction: Int,
        onDismiss: () -> Unit,
        onActionSelected: (Int) -> Unit
    ) {
        val actions = listOf(
            SettingsManager.DOUBLE_TAP_OFF to stringResource(R.string.settings_double_tap_off),
            SettingsManager.DOUBLE_TAP_SWITCH_CAM to stringResource(R.string.settings_double_tap_switch_cam),
            SettingsManager.DOUBLE_TAP_TOGGLE_ZOOM to stringResource(R.string.settings_double_tap_toggle_zoom)
        )
    
        AlertDialog(
            onDismissRequest = onDismiss,
            icon = { Icon(Icons.Rounded.TouchApp, contentDescription = null) },
            title = { Text(stringResource(R.string.settings_double_tap_title)) },
            text = {
                Column(Modifier.verticalScroll(rememberScrollState())) {
                    actions.forEach { (actionCode, actionName) ->
                        DialogRadioRow(
                            text = actionName,
                            selected = (currentAction == actionCode),
                            onClick = { onActionSelected(actionCode) }
                        )
                    }
                }
            },
            confirmButton = {
                TextButton(onClick = onDismiss) {
                    Text(stringResource(R.string.settings_close))
                }
            }
        )
    }
    @OptIn(ExperimentalMaterial3Api::class)
    @Composable
    fun AntiFlickerDialog(
        currentMode: Int,
        onDismiss: () -> Unit,
        onModeSelected: (Int) -> Unit
    ) {
        val modes = listOf(
            SettingsManager.ANTI_FLICKER_AUTO to stringResource(R.string.settings_flicker_auto),
            SettingsManager.ANTI_FLICKER_OFF to stringResource(R.string.settings_flicker_off),
            SettingsManager.ANTI_FLICKER_50HZ to stringResource(R.string.settings_flicker_50hz),
            SettingsManager.ANTI_FLICKER_60HZ to stringResource(R.string.settings_flicker_60hz)
        )
    
        AlertDialog(
            onDismissRequest = onDismiss,
            icon = { Icon(Icons.Rounded.Block, contentDescription = null) },
            title = { Text(stringResource(R.string.settings_flicker_title)) },
            text = {
                Column(Modifier.verticalScroll(rememberScrollState())) {
                    modes.forEach { (modeCode, modeName) ->
                        DialogRadioRow(
                            text = modeName,
                            selected = (currentMode == modeCode),
                            onClick = { onModeSelected(modeCode) }
                        )
                    }
                }
            },
            confirmButton = {
                TextButton(onClick = onDismiss) {
                    Text(stringResource(R.string.settings_close))
                }
            }
        )
    }
    @OptIn(ExperimentalMaterial3Api::class)
    @Composable
    fun NoiseReductionDialog(
        currentMode: Int,
        onDismiss: () -> Unit,
        onModeSelected: (Int) -> Unit
    ) {
        val modes = listOf(
            SettingsManager.NR_AUTO to stringResource(R.string.settings_noise_reduction_auto),
            SettingsManager.NR_OFF to stringResource(R.string.settings_noise_reduction_off),
            SettingsManager.NR_LOW to stringResource(R.string.settings_noise_reduction_low),
            SettingsManager.NR_HIGH to stringResource(R.string.settings_noise_reduction_high)
        )
    
        AlertDialog(
            onDismissRequest = onDismiss,
            icon = { Icon(Icons.Rounded.Grain, contentDescription = null) },
            title = { Text(stringResource(R.string.settings_noise_reduction_title)) },
            text = {
                Column(Modifier.verticalScroll(rememberScrollState())) {
                    modes.forEach { (modeCode, modeName) ->
                        DialogRadioRow(
                            text = modeName,
                            selected = (currentMode == modeCode),
                            onClick = { onModeSelected(modeCode) }
                        )
                    }
                }
            },
            confirmButton = {
                TextButton(onClick = onDismiss) {
                    Text(stringResource(R.string.settings_close))
                }
            }
        )
    }
    
    @Composable
    private fun DialogRadioRow(
        text: String,
        selected: Boolean,
        onClick: () -> Unit
    ) {
        Row(
            Modifier
                .fillMaxWidth()
                .selectable(
                    selected = selected,
                    onClick = onClick,
                    role = Role.RadioButton
                )
                .padding(vertical = 12.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            RadioButton(
                selected = selected,
                onClick = null
            )
            Text(
                text = text,
                style = MaterialTheme.typography.bodyLarge,
                modifier = Modifier.padding(start = 16.dp)
            )
        }
    }
    @Composable
    fun <T> SettingsRadioDialog(
        title: String,
        options: Map<T, String>,
        selected: T,
        onDismiss: () -> Unit,
        onSelected: (T) -> Unit
    ) {
        AlertDialog(
            onDismissRequest = onDismiss,
            title = { Text(text = title) },
            text = {
                Column(Modifier.verticalScroll(rememberScrollState())) {
                    options.forEach { (key, text) ->
                        Row(
                            Modifier
                                .fillMaxWidth()
                                .height(56.dp)
                                .selectable(
                                    selected = (key == selected),
                                    onClick = { onSelected(key) },
                                    role = Role.RadioButton
                                )
                                .padding(horizontal = 16.dp),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            RadioButton(
                                selected = (key == selected),
                                onClick = null
                            )
                            Text(
                                text = text,
                                style = MaterialTheme.typography.bodyLarge,
                                modifier = Modifier.padding(start = 16.dp)
                            )
                        }
                    }
                }
            },
            confirmButton = {
                TextButton(onClick = onDismiss) {
                    Text(stringResource(R.string.settings_close))
                }
            }
        )
    }
    @OptIn(ExperimentalMaterial3Api::class)
    @Composable
    fun VolumeActionDialog(
        currentAction: Int,
        onDismiss: () -> Unit,
        onActionSelected: (Int) -> Unit
    ) {
        val actions = mapOf(
            SettingsManager.VOL_ACTION_OFF to stringResource(R.string.settings_volume_action_off),
            SettingsManager.VOL_ACTION_ZOOM to stringResource(R.string.settings_volume_action_zoom),
            SettingsManager.VOL_ACTION_SWITCH_CAM to stringResource(R.string.settings_volume_action_switch_cam),
            SettingsManager.VOL_ACTION_TOGGLE_FLASH to stringResource(R.string.settings_volume_action_toggle_flash)
        )
    
        SettingsRadioDialog(
            title = stringResource(R.string.settings_volume_action_title),
            options = actions,
            selected = currentAction,
            onDismiss = onDismiss,
            onSelected = { newAction ->
                onActionSelected(newAction)
                onDismiss()
            }
        )
    }
    @OptIn(ExperimentalMaterial3Api::class)
    @Composable
    fun AutoDimDialog(
        currentDelay: Int,
        onDismiss: () -> Unit,
        onDelaySelected: (Int) -> Unit
    ) {
        val options = mapOf(
            SettingsManager.DIM_DELAY_OFF to stringResource(R.string.settings_power_auto_dim_off),
            SettingsManager.DIM_DELAY_45S to stringResource(R.string.settings_power_auto_dim_45s),
            SettingsManager.DIM_DELAY_1M to stringResource(R.string.settings_power_auto_dim_1m),
            SettingsManager.DIM_DELAY_90S to stringResource(R.string.settings_power_auto_dim_90s),
            SettingsManager.DIM_DELAY_2M to stringResource(R.string.settings_power_auto_dim_2m),
            SettingsManager.DIM_DELAY_3M to stringResource(R.string.settings_power_auto_dim_3m),
            SettingsManager.DIM_DELAY_5M to stringResource(R.string.settings_power_auto_dim_5m)
        )
    
        SettingsRadioDialog(
            title = stringResource(R.string.settings_power_auto_dim_dialog_title),
            options = options,
            selected = currentDelay,
            onDismiss = onDismiss,
            onSelected = { newDelay ->
                onDelaySelected(newDelay)
                onDismiss()
            }
        )
    }
    
    @OptIn(ExperimentalMaterial3Api::class)
    @Composable
    fun ZoomSmoothingDialog(
        currentDelay: Int,
        onDismiss: () -> Unit,
        onDelaySelected: (Int) -> Unit
    ) {
        val options = mapOf(
            SettingsManager.SMOOTH_DELAY_NONE to stringResource(R.string.settings_zoom_smoothing_none),
            SettingsManager.SMOOTH_DELAY_5 to "5 ms",
            SettingsManager.SMOOTH_DELAY_8 to "8 ms",
            SettingsManager.SMOOTH_DELAY_10 to "10 ms",
            SettingsManager.SMOOTH_DELAY_15 to "15 ms",
            SettingsManager.SMOOTH_DELAY_20 to "20 ms",
            SettingsManager.SMOOTH_DELAY_25 to "25 ms",
            SettingsManager.SMOOTH_DELAY_30 to "30 ms",
            SettingsManager.SMOOTH_DELAY_40 to "40 ms",
            SettingsManager.SMOOTH_DELAY_50 to "50 ms"
        )
    
        AlertDialog(
            onDismissRequest = onDismiss,
            icon = { Icon(Icons.Rounded.Movie, contentDescription = null) },
            title = { Text(stringResource(R.string.settings_zoom_smoothing_dialog_title)) },
            text = {
                Column(Modifier.verticalScroll(rememberScrollState())) {
                    options.forEach { (delayMs, text) ->
                        DialogRadioRow(
                            text = text,
                            selected = (currentDelay == delayMs),
                            onClick = { onDelaySelected(delayMs) }
                        )
                    }
                }
            },
            confirmButton = {
                TextButton(onClick = onDismiss) {
                    Text(stringResource(R.string.settings_close))
                }
            }
        )
    }
    @OptIn(ExperimentalMaterial3Api::class)
    @Composable
    fun PortSettingDialog(
        currentPort: Int,
        onDismiss: () -> Unit,
        onSave: (Int) -> Unit
    ) {
        var text by rememberSaveable { mutableStateOf(currentPort.toString()) }
        var isError by rememberSaveable { mutableStateOf(false) }
    
        fun validate(portStr: String): Int? {
            val port = portStr.toIntOrNull()
            return if (port != null && port in 1025..65535) {
                port
            } else {
                null
            }
        }
    
        AlertDialog(
            onDismissRequest = onDismiss,
            icon = { Icon(Icons.Rounded.SettingsEthernet, contentDescription = null) },
            title = { Text(stringResource(R.string.settings_port_dialog_title)) },
            text = {
                Column {
                    TextField(
                        value = text,
                        onValueChange = {
                            text = it
                            isError = validate(it) == null
                        },
                        label = { Text(stringResource(R.string.settings_port_dialog_label)) },
                        singleLine = true,
                        keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),
                        isError = isError
                    )
                    if (isError) {
                        Text(
                            text = stringResource(R.string.settings_port_dialog_invalid),
                            color = MaterialTheme.colorScheme.error,
                            style = MaterialTheme.typography.bodySmall,
                            modifier = Modifier.padding(top = 8.dp)
                        )
                    }
                }
            },
            confirmButton = {
                TextButton(
                    onClick = {
                        val validPort = validate(text)
                        if (validPort != null) {
                            onSave(validPort)
                            onDismiss()
                        }
                    }
                ) {
                    Text(stringResource(R.string.settings_save))
                }
            },
            dismissButton = {
                TextButton(onClick = onDismiss) {
                    Text(stringResource(R.string.settings_close))
                }
            }
        )
    }
    


================================================================================
FICHIER : \AndroidStudioProjects\RemoteCam-Enhanced\app\src\main\java\com\samsung\android\scan3d\http\HttpService.kt
================================================================================
    package com.samsung.android.scan3d.http
    
    import android.content.Context
    import android.util.Log
    import com.samsung.android.scan3d.util.SettingsManager
    import io.ktor.http.ContentType
    import io.ktor.http.HttpStatusCode
    import io.ktor.server.application.*
    import io.ktor.server.engine.*
    import io.ktor.server.netty.*
    import io.ktor.server.response.*
    import io.ktor.server.routing.*
    import kotlinx.coroutines.channels.Channel
    import kotlinx.coroutines.channels.consumeEach
    import java.io.OutputStream
    
    class HttpService(private val context: Context) {
        private lateinit var engine: NettyApplicationEngine
        private lateinit var imageChannel: Channel<ByteArray>
    
        private var currentPort: Int = 0
    
        /**
         * A suspendable lambda that consumes image data from a channel and writes it to an
         * OutputStream in MJPEG format. This continues until the client disconnects.
         */
        private fun producer(): suspend OutputStream.() -> Unit = {
            val outputStream = this
    
            try {
                imageChannel.consumeEach { frameData ->
                    outputStream.write("--FRAME\r\nContent-Type: image/jpeg\r\n\r\n".toByteArray())
                    outputStream.write(frameData)
                    outputStream.flush()
                }
            } catch (_: Exception) {
                // This exception is expected when the client disconnects or the channel is closed.
                // No action is needed.
            }
        }
    
        /**
         * Initializes and starts the Ktor embedded server.
         */
        fun start() {
            imageChannel = Channel(Channel.CONFLATED)
            if (currentPort == 0) {
                currentPort = SettingsManager.loadPort(context)
            }
    
            engine = embeddedServer(Netty, port = currentPort) {
                routing {
                    get("/cam") {
                        call.respondText("Ok")
                    }
                    get("/cam.mjpeg") {
                        call.respondOutputStream(
                            contentType = ContentType.parse("multipart/x-mixed-replace;boundary=FRAME"),
                            status = HttpStatusCode.OK,
                            producer = producer()
                        )
                    }
                }
            }
            engine.start(wait = false)
        }
    
        /**
         * Gracefully stops the Ktor server engine.
         */
        fun stop() {
            if (::engine.isInitialized) {
                Log.i("HttpService", "Stopping server...")
                try {
                    engine.stop(100, 100)
                } catch (e: Exception) {
                    Log.w("HttpService", "Error while stopping server: ${e.message}")
                }
            }
        }
    
        /**
         * Stops the current server instance and starts a new one on the specified port.
         * Does nothing if the new port is the same as the current one.
         *
         * @param newPort The new port to run the server on.
         */
        fun restartServer(newPort: Int) {
            if (newPort == currentPort) return
            Log.i("HttpService", "Restarting server on port $newPort")
            stop() // Use the new stop function
            currentPort = newPort
            start()
        }
    
        /**
         * Sends a new image frame to the MJPEG stream.
         * It uses `trySend` to avoid blocking if the channel is full.
         *
         * @param bytes The ByteArray of the JPEG image frame.
         */
        fun sendFrame(bytes: ByteArray) {
            if (::imageChannel.isInitialized) {
                imageChannel.trySend(bytes)
            }
        }
    }
    


================================================================================
FICHIER : \AndroidStudioProjects\RemoteCam-Enhanced\app\src\main\java\com\samsung\android\scan3d\screens\AdditionalSettingsScreen.kt
================================================================================
    package com.samsung.android.scan3d.screens
    
    import android.content.Intent
    import androidx.compose.runtime.Composable
    import androidx.compose.ui.platform.LocalContext
    import com.samsung.android.scan3d.fragments.CameraSettingsScreen
    import com.samsung.android.scan3d.serv.Cam
    
    @Composable
    fun AdditionalSettingsScreen(
        onBackClicked: () -> Unit
    ) {
        val context = LocalContext.current
    
        fun sendIntentToCamService(action: String, extras: ((Intent) -> Unit) = {}) {
            val intent = Intent(context, Cam::class.java).apply {
                this.action = action
                extras(this)
            }
            context.startService(intent)
        }
    
        CameraSettingsScreen(
            onBackClicked = onBackClicked,
            onSendFpsIntent = { fps ->
                sendIntentToCamService("set_target_fps") { it.putExtra("fps", fps) }
            },
            onSendAntiFlickerIntent = { mode ->
                sendIntentToCamService("set_anti_flicker") { it.putExtra("mode", mode) }
            },
            onSendNoiseReductionIntent = { mode ->
                sendIntentToCamService("set_noise_reduction") { it.putExtra("mode", mode) }
            },
            onSendStabilizationIntent = { isOff ->
                sendIntentToCamService("set_stabilization") { it.putExtra("is_off", isOff) }
            },
            onSendZoomSmoothingIntent = { delay ->
                sendIntentToCamService("set_zoom_smoothing") { it.putExtra("delay", delay) }
            }
        )
    }
    


================================================================================
FICHIER : \AndroidStudioProjects\RemoteCam-Enhanced\app\src\main\java\com\samsung\android\scan3d\screens\CameraScreen.kt
================================================================================
    package com.samsung.android.scan3d.screens
    
    import android.annotation.SuppressLint
    import android.content.BroadcastReceiver
    import android.content.Context
    import android.content.Intent
    import android.content.IntentFilter
    import android.hardware.camera2.CameraManager
    import android.view.Surface
    import android.view.TextureView
    import android.view.WindowManager
    import android.widget.Toast
    import androidx.compose.material3.ExperimentalMaterial3Api
    import androidx.compose.runtime.*
    import androidx.compose.ui.hapticfeedback.HapticFeedbackType
    import androidx.compose.ui.platform.LocalContext
    import androidx.compose.ui.platform.LocalHapticFeedback
    import androidx.lifecycle.Lifecycle
    import androidx.lifecycle.LifecycleEventObserver
    import androidx.lifecycle.compose.LocalLifecycleOwner // Correct, non-deprecated import
    import com.samsung.android.scan3d.CameraActivity
    import com.samsung.android.scan3d.R
    import com.samsung.android.scan3d.ViewState
    import com.samsung.android.scan3d.serv.CamEngine
    import com.samsung.android.scan3d.util.ClipboardUtil
    import com.samsung.android.scan3d.util.IpUtil
    import com.samsung.android.scan3d.util.Selector
    import com.samsung.android.scan3d.util.SettingsManager
    
    @OptIn(ExperimentalMaterial3Api::class)
    @Composable
    fun CameraScreen(
        cameraActivity: CameraActivity,
        onNavigateToSettings: () -> Unit,
        isInputLocked: Boolean
    ) {
        val context = LocalContext.current
        val haptics = LocalHapticFeedback.current
    
        val cameraManager = remember { context.getSystemService(Context.CAMERA_SERVICE) as CameraManager }
        // Initialize defaultCameraId directly to avoid an unused 'cameraList' variable.
        val defaultCameraId = remember { Selector.enumerateCameras(cameraManager).firstOrNull()?.cameraId ?: "0" }
    
        val initialViewState = remember {
            SettingsManager.loadViewState(context, defaultCameraId)
        }
    
        var viewState by remember { mutableStateOf(initialViewState) }
        var zoomSliderPosition by remember { mutableFloatStateOf(0.0f) }
        var camData by remember { mutableStateOf<CamEngine.Companion.Data?>(null) }
        var quickData by remember { mutableStateOf<CamEngine.Companion.DataQuick?>(null) }
        var localIp by remember { mutableStateOf("0.0.0.0:8080/cam.mjpeg") }
    
        val textureView = remember {
            TextureView(context)
        }
    
        var previewSurface by remember { mutableStateOf<Surface?>(null) }
    
        LaunchedEffect(Unit) {
            IpUtil.getLocalIpAddress()?.let {
                val port = SettingsManager.loadPort(context)
                localIp = "$it:$port/cam.mjpeg"
            }
        }
    
        val lifecycleOwner = LocalLifecycleOwner.current
        DisposableEffect(lifecycleOwner) {
            val window = cameraActivity.window
    
            val observer = LifecycleEventObserver { _, event ->
                when (event) {
                    Lifecycle.Event.ON_PAUSE -> {
                        window.clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)
                    }
                    Lifecycle.Event.ON_RESUME -> {
                        val keepScreenOn = SettingsManager.loadKeepScreenOn(context)
                        if (keepScreenOn) {
                            window.addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)
                        } else {
                            window.clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)
                        }
                    }
                    else -> {}
                }
            }
            lifecycleOwner.lifecycle.addObserver(observer)
    
            onDispose {
                lifecycleOwner.lifecycle.removeObserver(observer)
                window.clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)
            }
        }
    
        DisposableEffect(context) {
            val receiver = object : BroadcastReceiver() {
                @SuppressLint("UnsafeParcelable")
                override fun onReceive(ctx: Context, intent: Intent) {
                    if (intent.action == "PORT_UPDATED") {
                        IpUtil.getLocalIpAddress()?.let {
                            val port = SettingsManager.loadPort(context)
                            localIp = "$it:$port/cam.mjpeg"
                        }
                        return
                    }
    
                    val extras = intent.extras ?: return
                    // Using the modern, type-safe getParcelable API directly.
                    // This is safe because minSdkVersion is 33 or higher.
                    quickData = extras.getParcelable("dataQuick", CamEngine.Companion.DataQuick::class.java)
                    val data = extras.getParcelable("data", CamEngine.Companion.Data::class.java)
    
                    data?.let { d ->
                        camData = d
    
                        val engineQuality = d.quality
                        val engineResolutionIndex = d.resolutionSelected
                        val engineCameraId = d.sensorSelected.cameraId
                        val engineFlashState = d.flashState
    
                        var stateChanged = false
                        var newViewState = viewState
    
                        if (viewState.cameraId != engineCameraId) {
                            newViewState = newViewState.copy(
                                cameraId = engineCameraId,
                                flash = engineFlashState,
                                resolutionIndex = engineResolutionIndex
                            )
                            stateChanged = true
                        }
    
                        if (viewState.resolutionIndex != engineResolutionIndex) {
                            newViewState = newViewState.copy(resolutionIndex = engineResolutionIndex)
                            stateChanged = true
                        }
    
                        if (viewState.quality != engineQuality) {
                            newViewState = newViewState.copy(quality = engineQuality)
                            stateChanged = true
                        }
    
                        if (viewState.flash != engineFlashState) {
                            newViewState = newViewState.copy(flash = engineFlashState)
                            stateChanged = true
                        }
    
                        if (stateChanged) viewState = newViewState
    
                        if (d.maxZoom > 1.0f) {
                            val ratio = (d.currentZoom - 1.0f) / (d.maxZoom - 1.0f)
                            zoomSliderPosition = ratio.coerceIn(0.0f, 1.0f)
                        } else {
                            zoomSliderPosition = 0.0f
                        }
                    }
                }
            }
            val filter = IntentFilter("UpdateFromCameraEngine")
            filter.addAction("PORT_UPDATED")
            context.registerReceiver(receiver, filter, Context.RECEIVER_NOT_EXPORTED)
            onDispose { context.unregisterReceiver(receiver) }
        }
    
        fun sendViewState(newState: ViewState) {
            viewState = newState
            SettingsManager.saveSettings(context, viewState)
            cameraActivity.sendCam {
                it.action = "new_view_state"
                it.putExtra("data", viewState)
            }
        }
    
        fun handleDoubleTap() {
            val action = SettingsManager.loadDoubleTapAction(context)
            val intentAction = when (action) {
                SettingsManager.DOUBLE_TAP_SWITCH_CAM -> "double_tap_action_switch_camera"
                SettingsManager.DOUBLE_TAP_TOGGLE_ZOOM -> "double_tap_action_toggle_zoom"
                else -> null
            }
            intentAction?.let { cameraActivity.sendCam { intent -> intent.action = it } }
        }
    
        CameraScreenUI(
            textureView = textureView,
            camData = camData,
            quickData = quickData,
            viewState = viewState,
            localIp = localIp,
            zoomSliderPosition = zoomSliderPosition,
            isInputLocked = isInputLocked,
            onSurfaceAvailable = { surface ->
                previewSurface?.release()
                previewSurface = surface
    
                cameraActivity.sendCam {
                    it.action = "start_engine_with_surface"
                    it.putExtra("surface", surface)
                }
            },
            onSurfaceDestroyed = {
                cameraActivity.sendCam { it.action = "preview_surface_destroyed" }
                previewSurface?.release()
                previewSurface = null
            },
            onStopClicked = {
                cameraActivity.sendCam { it.action = "KILL" }
                cameraActivity.finishAndRemoveTask()
            },
            onPreviewToggled = { isChecked -> sendViewState(viewState.copy(preview = isChecked)) },
            onStreamToggled = { isChecked -> sendViewState(viewState.copy(stream = isChecked)) },
            onFlashToggled = { isChecked -> sendViewState(viewState.copy(flash = isChecked)) },
            onSensorSelected = { index ->
                camData?.sensors?.getOrNull(index)?.let { sensor ->
                    val newCamId = sensor.cameraId
                    val oldCamId = viewState.cameraId
                    sendViewState(
                        viewState.copy(
                            cameraId = newCamId,
                            resolutionIndex = if (oldCamId != newCamId) null else viewState.resolutionIndex,
                            flash = false
                        )
                    )
                }
            },
            onResolutionSelected = { index ->
                // Simplified check to avoid unused 'let' lambda variable.
                if (camData?.resolutions?.indices?.contains(index) == true) {
                    sendViewState(viewState.copy(resolutionIndex = index))
                }
            },
            onQualitySelected = { quality -> sendViewState(viewState.copy(quality = quality)) },
            onIpClicked = { ip ->
                ClipboardUtil.copyToClipboard(context, "ip", ip)
                Toast.makeText(context, R.string.cam_clipboard_copied, Toast.LENGTH_SHORT).show()
            },
            onZoomScaleChanged = { scaleFactor ->
                camData?.let { data ->
                    if (data.maxZoom > 1.0f) {
                        val currentZoom = data.currentZoom
                        val maxZoom = data.maxZoom
                        val newZoom = (currentZoom * scaleFactor).coerceIn(1.0f, maxZoom)
                        val newRatio = (newZoom - 1.0f) / (maxZoom - 1.0f)
                        zoomSliderPosition = newRatio.coerceIn(0.0f, 1.0f)
                    }
                }
    
                cameraActivity.sendCam {
                    it.action = "scale_zoom"
                    it.putExtra("scale_factor", scaleFactor)
                }
            },
            onZoomRatioChanged = { newPosition ->
                zoomSliderPosition = newPosition
    
                haptics.performHapticFeedback(HapticFeedbackType.TextHandleMove)
    
                cameraActivity.sendCam {
                    it.action = "set_zoom_ratio"
                    it.putExtra("ratio", newPosition)
                }
            },
            onSettingsClicked = onNavigateToSettings,
            onDoubleTapped = { handleDoubleTap() }
        )
    }
    


================================================================================
FICHIER : \AndroidStudioProjects\RemoteCam-Enhanced\app\src\main\java\com\samsung\android\scan3d\screens\CameraScreenUI.kt
================================================================================
    package com.samsung.android.scan3d.screens
    
    import android.annotation.SuppressLint
    import android.graphics.Matrix
    import android.graphics.RectF
    import android.graphics.SurfaceTexture
    import android.view.GestureDetector
    import android.view.MotionEvent
    import android.view.ScaleGestureDetector
    import android.view.Surface
    import android.view.TextureView
    import androidx.compose.foundation.background
    import androidx.compose.foundation.clickable
    import androidx.compose.foundation.layout.*
    import androidx.compose.foundation.rememberScrollState
    import androidx.compose.foundation.shape.RoundedCornerShape
    import androidx.compose.foundation.verticalScroll
    import androidx.compose.material.icons.Icons
    import androidx.compose.material.icons.filled.Link
    import androidx.compose.material.icons.filled.Settings
    import androidx.compose.material.icons.filled.Videocam
    import androidx.compose.material.icons.filled.ZoomIn
    import androidx.compose.material.icons.filled.ZoomOut
    import androidx.compose.material3.*
    import androidx.compose.runtime.*
    import androidx.compose.ui.Alignment
    import androidx.compose.ui.Modifier
    import androidx.compose.ui.graphics.Color
    import androidx.compose.ui.platform.LocalContext
    import androidx.compose.ui.platform.LocalUriHandler
    import androidx.compose.ui.res.stringResource
    import androidx.compose.ui.text.font.FontWeight
    import androidx.compose.ui.tooling.preview.Preview
    import androidx.compose.ui.unit.dp
    import androidx.compose.ui.viewinterop.AndroidView
    import com.samsung.android.scan3d.R
    import com.samsung.android.scan3d.ViewState
    import com.samsung.android.scan3d.fragments.AnimatedSystemSwitch
    import com.samsung.android.scan3d.serv.CamEngine
    import com.samsung.android.scan3d.serv.CamEngine.Companion.ParcelableSize
    import com.samsung.android.scan3d.ui.theme.RemoteCamM3Theme
    import com.samsung.android.scan3d.util.Selector
    import androidx.compose.material3.ExperimentalMaterial3Api
    
    val QUALITIES = listOf(1, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100)
    
    @SuppressLint("ClickableViewAccessibility")
    @OptIn(ExperimentalMaterial3Api::class)
    @Composable
    fun CameraScreenUI(
        textureView: TextureView,
        camData: CamEngine.Companion.Data?,
        quickData: CamEngine.Companion.DataQuick?,
        viewState: ViewState,
        localIp: String,
        zoomSliderPosition: Float,
        isInputLocked: Boolean,
        onSurfaceAvailable: (Surface) -> Unit,
        onSurfaceDestroyed: () -> Unit,
        onStopClicked: () -> Unit,
        onPreviewToggled: (Boolean) -> Unit,
        onStreamToggled: (Boolean) -> Unit,
        onFlashToggled: (Boolean) -> Unit,
        onSensorSelected: (Int) -> Unit,
        onResolutionSelected: (Int) -> Unit,
        onQualitySelected: (Int) -> Unit,
        onIpClicked: (String) -> Unit,
        onZoomScaleChanged: (Float) -> Unit,
        onZoomRatioChanged: (Float) -> Unit,
        onSettingsClicked: () -> Unit,
        onDoubleTapped: () -> Unit
    ) {
    
        Scaffold(
            topBar = {
                TopAppBar(
                    title = { Text(stringResource(R.string.app_name), fontWeight = FontWeight.Bold) },
                    colors = TopAppBarDefaults.topAppBarColors(
                        containerColor = MaterialTheme.colorScheme.primaryContainer,
                        titleContentColor = MaterialTheme.colorScheme.onPrimaryContainer
                    ),
                    actions = {
                        Text(
                            text = "${quickData?.ms ?: 0}ms / ${quickData?.rateKbs ?: 0}kB/s",
                            modifier = Modifier.padding(end = 8.dp),
                            color = MaterialTheme.colorScheme.onPrimaryContainer,
                            style = MaterialTheme.typography.bodyMedium
                        )
                        IconButton(onClick = onSettingsClicked) {
                            Icon(
                                Icons.Default.Settings,
                                contentDescription = stringResource(R.string.cam_settings),
                                tint = MaterialTheme.colorScheme.onPrimaryContainer
                            )
                        }
                    }
                )
            },
            floatingActionButton = {
                ExtendedFloatingActionButton(
                    onClick = onStopClicked,
                    text = { Text(stringResource(R.string.cam_stop)) },
                    icon = { Icon(Icons.Default.Videocam, contentDescription = stringResource(R.string.cam_stop)) },
                    containerColor = MaterialTheme.colorScheme.errorContainer,
                    contentColor = MaterialTheme.colorScheme.onErrorContainer
                )
            }
        ) { paddingValues ->
            Column(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(paddingValues)
            ) {
    
                Box(
                    modifier = Modifier
                        .weight(1f)
                        .fillMaxWidth()
                        .background(Color.Black),
                    contentAlignment = Alignment.Center
                ) {
                    AndroidView(
                        factory = { context ->
    
                            val scaleGestureDetector = ScaleGestureDetector(context,
                                object : ScaleGestureDetector.SimpleOnScaleGestureListener() {
                                    override fun onScale(detector: ScaleGestureDetector): Boolean {
                                        onZoomScaleChanged(detector.scaleFactor)
                                        return true
                                    }
                                }
                            )
    
                            val gestureDetector = GestureDetector(
                                context,
                                object : GestureDetector.SimpleOnGestureListener() {
                                    override fun onDoubleTap(e: MotionEvent): Boolean {
                                        onDoubleTapped()
                                        return true
                                    }
    
                                    override fun onSingleTapUp(e: MotionEvent): Boolean {
                                        textureView.performClick()
                                        return true
                                    }
                                }
                            )
    
                            textureView.apply {
                                surfaceTextureListener = object : TextureView.SurfaceTextureListener {
    
                                    private fun configureTransform(viewWidth: Int, viewHeight: Int) {
                                        val orientation = camData?.sensorOrientation ?: 90
                                        if (camData == null || viewWidth == 0 || viewHeight == 0) {
                                            return
                                        }
    
                                        val matrix = Matrix()
                                        val viewRect = RectF(0f, 0f, viewWidth.toFloat(), viewHeight.toFloat())
                                        val centerX = viewRect.centerX()
                                        val centerY = viewRect.centerY()
    
                                        val bufferWidth: Int
                                        val bufferHeight: Int
                                        camData.resolutions.getOrNull(viewState.resolutionIndex ?: 0)?.let {
                                            bufferWidth = it.width
                                            bufferHeight = it.height
                                        } ?: return
    
                                        val logicalBufferWidth: Int
                                        val logicalBufferHeight: Int
                                        if (orientation == 90 || orientation == 270) {
                                            logicalBufferWidth = bufferHeight // 1080
                                            logicalBufferHeight = bufferWidth  // 1920
                                        } else {
                                            logicalBufferWidth = bufferWidth
                                            logicalBufferHeight = bufferHeight
                                        }
    
                                        val scale: Float
                                        val scaleX = viewWidth.toFloat() / logicalBufferWidth.toFloat()
                                        val scaleY = viewHeight.toFloat() / logicalBufferHeight.toFloat()
    
                                        scale = maxOf(scaleX, scaleY)
    
                                        matrix.postScale(scale, scale, centerX, centerY)
    
                                        if (orientation == 90 || orientation == 270) {
                                            matrix.postRotate((orientation - 90).toFloat(), centerX, centerY)
                                        } else if (orientation == 180) {
                                            matrix.postRotate(180f, centerX, centerY)
                                        }
    
                                        textureView.setTransform(matrix)
                                    }
    
    
                                    override fun onSurfaceTextureAvailable(st: SurfaceTexture, width: Int, height: Int) {
                                        configureTransform(width, height)
                                        val surface = Surface(st)
                                        onSurfaceAvailable(surface)
                                    }
    
                                    override fun onSurfaceTextureSizeChanged(st: SurfaceTexture, width: Int, height: Int) {
                                        configureTransform(width, height)
                                    }
    
                                    override fun onSurfaceTextureDestroyed(st: SurfaceTexture): Boolean {
                                        onSurfaceDestroyed()
                                        return true
                                    }
    
                                    override fun onSurfaceTextureUpdated(st: SurfaceTexture) {}
                                }
    
                                setOnClickListener { }
                                setOnTouchListener { _, event ->
                                    scaleGestureDetector.onTouchEvent(event)
                                    gestureDetector.onTouchEvent(event)
                                    true
                                }
                            }
                        },
                    )
                }
    
                Column(
                    modifier = Modifier
                        .weight(1f)
                        .fillMaxWidth()
                ) {
                    Column(
                        modifier = Modifier
                            .fillMaxSize()
                            .verticalScroll(rememberScrollState())
                            .padding(16.dp),
                        verticalArrangement = Arrangement.spacedBy(12.dp)
                    ) {
                        ControlGroup(title = stringResource(R.string.cam_controls)) {
                            ControlRow(label = stringResource(R.string.cam_local_preview)) {
                                AnimatedSystemSwitch(checked = viewState.preview, onCheckedChange = onPreviewToggled)
                            }
                            ControlRow(label = stringResource(R.string.cam_mjpeg_stream)) {
                                AnimatedSystemSwitch(checked = viewState.stream, onCheckedChange = onStreamToggled)
                            }
                            if (camData?.hasFlash == true) {
                                ControlRow(label = stringResource(R.string.cam_flash)) {
                                    AnimatedSystemSwitch(
                                        checked = viewState.flash,
                                        onCheckedChange = onFlashToggled,
                                    )
                                }
                            }
                        }
    
                        if (camData != null && viewState.resolutionIndex != null) {
                            ControlGroup(title = stringResource(R.string.cam_parameters)) {
                                DropdownControl(
                                    label = stringResource(R.string.cam_sensor),
                                    options = camData.sensors.map { it.title },
                                    selectedIndex = camData.sensors.indexOfFirst { it.cameraId == viewState.cameraId },
                                    onSelected = onSensorSelected
                                )
    
                                DropdownControl(
                                    label = stringResource(R.string.cam_resolution),
                                    options = camData.resolutions.map { it.toString() },
                                    selectedIndex = viewState.resolutionIndex!!,
                                    onSelected = onResolutionSelected
                                )
    
                                DropdownControl(
                                    label = stringResource(R.string.cam_quality),
                                    options = QUALITIES.map { "$it%" },
                                    selectedIndex = QUALITIES.indexOf(viewState.quality),
                                    onSelected = { index -> onQualitySelected(QUALITIES[index]) }
                                )
    
                                if (camData.maxZoom > 1.0f) {
                                    Spacer(Modifier.height(8.dp))
                                    Text(
                                        text = "Zoom: ${"%.1f".format(camData.currentZoom)}x",
                                        style = MaterialTheme.typography.bodyMedium,
                                        fontWeight = FontWeight.SemiBold
                                    )
                                    Row(
                                        verticalAlignment = Alignment.CenterVertically,
                                        modifier = Modifier.fillMaxWidth()
                                    ) {
                                        Icon(Icons.Default.ZoomOut, null, modifier = Modifier.padding(end = 8.dp))
                                        Slider(
                                            value = zoomSliderPosition,
                                            onValueChange = onZoomRatioChanged,
                                            modifier = Modifier.weight(1f)
                                        )
                                        Icon(Icons.Default.ZoomIn, null, modifier = Modifier.padding(start = 8.dp))
                                    }
                                }
                            }
                        } else {
                            CircularProgressIndicator(modifier = Modifier.align(Alignment.CenterHorizontally))
                        }
    
                        ControlGroup(title = stringResource(R.string.cam_information)) {
                            Text(
                                text = localIp,
                                style = MaterialTheme.typography.bodyLarge,
                                modifier = Modifier
                                    .fillMaxWidth()
                                    .clickable { onIpClicked(localIp) }
                                    .padding(vertical = 8.dp)
                            )
    
                            val uriHandler = LocalUriHandler.current
                            val githubUrl = "https://github.com/alan7383/RemoteCam-Enhanced"
                            Row(
                                modifier = Modifier.clickable { uriHandler.openUri(githubUrl) },
                                verticalAlignment = Alignment.CenterVertically
                            ) {
                                Icon(Icons.Default.Link, contentDescription = "Lien", modifier = Modifier.size(16.dp))
                                Spacer(Modifier.width(4.dp))
                                Text(
                                    text = githubUrl,
                                    style = MaterialTheme.typography.bodyMedium,
                                    color = MaterialTheme.colorScheme.primary
                                )
                            }
                        }
                    }
                }
            }
        }
    }
    
    
    @Composable
    fun ControlGroup(title: String, content: @Composable ColumnScope.() -> Unit) {
        Card(
            shape = RoundedCornerShape(16.dp),
            colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceContainerLowest),
            modifier = Modifier.fillMaxWidth()
        ) {
            Column(modifier = Modifier.padding(16.dp)) {
                Text(
                    text = title,
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Bold,
                    color = MaterialTheme.colorScheme.primary,
                    modifier = Modifier.padding(bottom = 8.dp)
                )
                HorizontalDivider(modifier = Modifier.padding(bottom = 12.dp))
                Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {
                    content()
                }
            }
        }
    }
    
    @Composable
    fun ControlRow(label: String, content: @Composable () -> Unit) {
        Row(
            modifier = Modifier.fillMaxWidth(),
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.SpaceBetween
        ) {
            Text(text = label, style = MaterialTheme.typography.bodyLarge)
            content()
        }
    }
    
    @OptIn(ExperimentalMaterial3Api::class)
    @Composable
    fun DropdownControl(
        label: String,
        options: List<String>,
        selectedIndex: Int,
        onSelected: (Int) -> Unit
    ) {
        var expanded by remember { mutableStateOf(false) }
    
        Row(
            modifier = Modifier.fillMaxWidth(),
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.SpaceBetween
        ) {
            Text(text = label, style = MaterialTheme.typography.bodyLarge, modifier = Modifier.weight(1f))
    
            ExposedDropdownMenuBox(
                expanded = expanded,
                onExpandedChange = { expanded = !expanded },
                modifier = Modifier.weight(1f)
            ) {
                TextField(
                    value = options.getOrNull(selectedIndex) ?: "",
                    onValueChange = {},
                    readOnly = true,
                    trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = expanded) },
                    colors = TextFieldDefaults.colors(
                        focusedIndicatorColor = Color.Transparent,
                        unfocusedIndicatorColor = Color.Transparent
                    ),
                    modifier = Modifier.menuAnchor(ExposedDropdownMenuAnchorType.PrimaryNotEditable, enabled = true)
                )
    
                ExposedDropdownMenu(
                    expanded = expanded,
                    onDismissRequest = { expanded = false }
                ) {
                    options.forEachIndexed { index, text ->
                        DropdownMenuItem(
                            text = { Text(text) },
                            onClick = {
                                onSelected(index)
                                expanded = false
                            }
                        )
                    }
                }
            }
        }
    }
    
    
    @OptIn(ExperimentalMaterial3Api::class)
    @Preview(showBackground = true)
    @Composable
    fun CameraScreenPreview() {
        val fakeSensor1 = Selector.SensorDesc(cameraId = "0", title = "Caméra Arrière", format = 256)
        val fakeSensor2 = Selector.SensorDesc(cameraId = "1", title = "Caméra Avant", format = 256)
    
        val previewData = CamEngine.Companion.Data(
            sensors = listOf(fakeSensor1, fakeSensor2),
            sensorSelected = fakeSensor1,
            resolutions = listOf(
                ParcelableSize(1280, 720),
                ParcelableSize(1920, 1080)
            ),
            resolutionSelected = 0,
            currentZoom = 2.5f,
            maxZoom = 8.0f,
            hasFlash = true,
            quality = 80,
            flashState = true,
            sensorOrientation = 90
        )
    
        RemoteCamM3Theme {
            CameraScreenUI(
                textureView = TextureView(LocalContext.current),
                camData = previewData,
                quickData = CamEngine.Companion.DataQuick(16, 1200),
                viewState = ViewState(
                    preview = true,
                    stream = false,
                    cameraId = "0",
                    resolutionIndex = 0,
                    quality = 80,
                    flash = true
                ),
                localIp = "192.168.1.10:8080/cam.mjpeg",
                zoomSliderPosition = 0.2f,
                isInputLocked = true,
                onSurfaceAvailable = {},
                onSurfaceDestroyed = {},
                onStopClicked = {},
                onPreviewToggled = {},
                onStreamToggled = {},
                onFlashToggled = {},
                onSensorSelected = {},
                onResolutionSelected = {},
                onQualitySelected = {},
                onIpClicked = {},
                onZoomScaleChanged = {},
                onZoomRatioChanged = {},
                onSettingsClicked = {},
                onDoubleTapped = {}
            )
        }
    }
    


================================================================================
FICHIER : \AndroidStudioProjects\RemoteCam-Enhanced\app\src\main\java\com\samsung\android\scan3d\screens\PermissionScreen.kt
================================================================================
    package com.samsung.android.scan3d.screens
    
    import android.Manifest
    import android.widget.Toast
    import androidx.activity.compose.rememberLauncherForActivityResult
    import androidx.activity.result.contract.ActivityResultContracts
    import androidx.compose.runtime.Composable
    import androidx.compose.ui.platform.LocalContext
    import com.samsung.android.scan3d.R
    
    @Composable
    fun PermissionScreen(
        onNavigateToCamera: () -> Unit,
        onServiceStart: () -> Unit
    ) {
        val context = LocalContext.current
    
        val permissionsToRequest = arrayOf(
            Manifest.permission.CAMERA,
            Manifest.permission.POST_NOTIFICATIONS
        )
    
        val requestPermissionLauncher =
            rememberLauncherForActivityResult(ActivityResultContracts.RequestMultiplePermissions()) { permissions ->
                if (permissions.values.all { it }) {
                    onServiceStart()
                    onNavigateToCamera()
                } else {
                    Toast.makeText(
                        context,
                        context.getString(R.string.perm_toast_denied),
                        Toast.LENGTH_LONG
                    ).show()
                }
            }
    
        PermissionScreenUI(
            onAuthorizeClicked = {
                requestPermissionLauncher.launch(permissionsToRequest)
            }
        )
    }
    


================================================================================
FICHIER : \AndroidStudioProjects\RemoteCam-Enhanced\app\src\main\java\com\samsung\android\scan3d\screens\PermissionScreenUI.kt
================================================================================
    package com.samsung.android.scan3d.screens
    
    import androidx.compose.foundation.background
    import androidx.compose.foundation.layout.*
    import androidx.compose.foundation.shape.CircleShape
    import androidx.compose.material.icons.Icons
    import androidx.compose.material.icons.rounded.Camera
    import androidx.compose.material.icons.rounded.Notifications
    import androidx.compose.material3.*
    import androidx.compose.runtime.Composable
    import androidx.compose.ui.Alignment
    import androidx.compose.ui.Modifier
    import androidx.compose.ui.graphics.vector.ImageVector
    import androidx.compose.ui.res.stringResource
    import androidx.compose.ui.text.font.FontWeight
    import androidx.compose.ui.text.style.TextAlign
    import androidx.compose.ui.tooling.preview.Preview
    import androidx.compose.ui.unit.dp
    import com.samsung.android.scan3d.R
    import com.samsung.android.scan3d.ui.theme.RemoteCamM3Theme
    
    @OptIn(ExperimentalMaterial3Api::class)
    @Composable
    fun PermissionScreenUI(
        onAuthorizeClicked: () -> Unit
    ) {
        Scaffold(
            topBar = {
                TopAppBar(
                    title = { Text(stringResource(R.string.perm_welcome_title)) },
                    colors = TopAppBarDefaults.topAppBarColors(
                        containerColor = MaterialTheme.colorScheme.surface,
                        titleContentColor = MaterialTheme.colorScheme.onSurface
                    )
                )
            },
            bottomBar = {
                BottomAppBar(
                    containerColor = MaterialTheme.colorScheme.surfaceContainer,
                ) {
                    Button(
                        onClick = onAuthorizeClicked,
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(horizontal = 16.dp, vertical = 8.dp)
                            .height(56.dp)
                    ) {
                        Text(
                            text = stringResource(R.string.perm_button),
                            style = MaterialTheme.typography.titleMedium
                        )
                    }
                }
            }
        ) { paddingValues ->
            Column(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(paddingValues)
                    .padding(16.dp),
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
    
                Spacer(Modifier.height(32.dp))
    
                Box(
                    modifier = Modifier
                        .size(120.dp)
                        .background(MaterialTheme.colorScheme.primaryContainer, CircleShape),
                    contentAlignment = Alignment.Center
                ) {
                    Icon(
                        imageVector = Icons.Rounded.Camera,
                        contentDescription = "Caméra",
                        modifier = Modifier.size(72.dp),
                        tint = MaterialTheme.colorScheme.onPrimaryContainer
                    )
                }
    
                Spacer(Modifier.height(24.dp))
    
                Text(
                    text = stringResource(R.string.perm_welcome),
                    style = MaterialTheme.typography.headlineSmall,
                    color = MaterialTheme.colorScheme.onSurface
                )
    
                Spacer(Modifier.height(16.dp))
    
                Text(
                    text = stringResource(R.string.perm_desc),
                    style = MaterialTheme.typography.bodyLarge,
                    textAlign = TextAlign.Center,
                    color = MaterialTheme.colorScheme.onSurfaceVariant,
                    modifier = Modifier.padding(horizontal = 16.dp)
                )
    
                Spacer(Modifier.height(32.dp))
    
                Card(
                    modifier = Modifier.fillMaxWidth(),
                    colors = CardDefaults.cardColors(
                        containerColor = MaterialTheme.colorScheme.surfaceContainerLowest
                    )
                ) {
                    Column(Modifier.padding(16.dp)) {
                        Text(
                            text = stringResource(R.string.perm_reasons_title),
                            style = MaterialTheme.typography.titleMedium,
                            fontWeight = FontWeight.Bold,
                            color = MaterialTheme.colorScheme.onSurface,
                            modifier = Modifier.padding(bottom = 8.dp)
                        )
                        HorizontalDivider(modifier = Modifier.padding(bottom = 12.dp))
                        PermissionInfoRow(
                            icon = Icons.Rounded.Camera,
                            text = stringResource(R.string.perm_cam_reason)
                        )
                        Spacer(Modifier.height(16.dp))
                        PermissionInfoRow(
                            icon = Icons.Rounded.Notifications,
                            text = stringResource(R.string.perm_notif_reason)
                        )
                    }
                }
            }
        }
    }
    
    @Composable
    fun PermissionInfoRow(
        icon: ImageVector,
        text: String
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(vertical = 8.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Icon(
                imageVector = icon,
                contentDescription = null,
                tint = MaterialTheme.colorScheme.primary,
                modifier = Modifier.size(32.dp)
            )
            Spacer(Modifier.width(16.dp))
            Text(
                text = text,
                style = MaterialTheme.typography.bodyLarge,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )
        }
    }
    
    @Preview(showBackground = true)
    @Composable
    fun PermissionScreenPreview() {
        RemoteCamM3Theme {
            PermissionScreenUI(onAuthorizeClicked = {})
        }
    }
    


================================================================================
FICHIER : \AndroidStudioProjects\RemoteCam-Enhanced\app\src\main\java\com\samsung\android\scan3d\screens\PowerSettingsScreen.kt
================================================================================
    package com.samsung.android.scan3d.screens
    
    import android.content.Context
    import android.content.Intent
    import android.os.PowerManager
    import android.provider.Settings
    import androidx.compose.foundation.clickable
    import androidx.compose.foundation.layout.Arrangement
    import androidx.compose.foundation.layout.Column
    import androidx.compose.foundation.layout.Row
    import androidx.compose.foundation.layout.fillMaxSize
    import androidx.compose.foundation.layout.fillMaxWidth
    import androidx.compose.foundation.layout.padding
    import androidx.compose.foundation.rememberScrollState
    import androidx.compose.foundation.shape.RoundedCornerShape
    import androidx.compose.foundation.verticalScroll
    import androidx.compose.material.icons.Icons
    import androidx.compose.material.icons.automirrored.filled.ArrowBack
    import androidx.compose.material.icons.rounded.*
    import androidx.compose.material3.*
    import androidx.compose.runtime.*
    import androidx.compose.ui.Alignment
    import androidx.compose.ui.Modifier
    import androidx.compose.ui.draw.clip
    import androidx.compose.ui.graphics.vector.ImageVector
    import androidx.compose.ui.platform.LocalContext
    import androidx.lifecycle.compose.LocalLifecycleOwner
    import androidx.compose.ui.res.stringResource
    import androidx.compose.ui.unit.dp
    import androidx.lifecycle.Lifecycle
    import androidx.lifecycle.LifecycleEventObserver
    import com.samsung.android.scan3d.R
    import com.samsung.android.scan3d.fragments.AnimatedSystemSwitch
    import com.samsung.android.scan3d.fragments.AutoDimDialog
    import com.samsung.android.scan3d.fragments.SettingsClickableRow
    import com.samsung.android.scan3d.fragments.SettingsGroup
    import com.samsung.android.scan3d.serv.Cam
    import com.samsung.android.scan3d.util.SettingsManager
    import androidx.compose.material.icons.rounded.SettingsEthernet
    import com.samsung.android.scan3d.fragments.PortSettingDialog
    import androidx.core.net.toUri
    import androidx.compose.ui.text.font.FontWeight
    
    
    @OptIn(ExperimentalMaterial3Api::class)
    @Composable
    fun PowerSettingsScreen(
        onBackClicked: () -> Unit
    ) {
        val context = LocalContext.current
    
        var showAutoDimDialog by remember { mutableStateOf(false) }
        var showPortDialog by remember { mutableStateOf(false) }
        var currentPort by remember { mutableIntStateOf(SettingsManager.loadPort(context)) }
        var currentDimDelay by remember { mutableIntStateOf(SettingsManager.loadAutoDimDelay(context)) }
        var lockInput by remember { mutableStateOf(SettingsManager.loadLockInputOnDim(context)) }
        var backgroundStreaming by remember { mutableStateOf(SettingsManager.loadBackgroundStreaming(context)) }
        var allowReconnects by remember { mutableStateOf(SettingsManager.loadAllowReconnects(context)) }
    
        @Composable
        fun getDimDelaySummary(delayMs: Int): String {
            return when (delayMs) {
                SettingsManager.DIM_DELAY_45S -> stringResource(R.string.settings_power_auto_dim_45s)
                SettingsManager.DIM_DELAY_1M -> stringResource(R.string.settings_power_auto_dim_1m)
                SettingsManager.DIM_DELAY_90S -> stringResource(R.string.settings_power_auto_dim_90s)
                SettingsManager.DIM_DELAY_2M -> stringResource(R.string.settings_power_auto_dim_2m)
                SettingsManager.DIM_DELAY_3M -> stringResource(R.string.settings_power_auto_dim_3m)
                SettingsManager.DIM_DELAY_5M -> stringResource(R.string.settings_power_auto_dim_5m)
                else -> stringResource(R.string.settings_power_auto_dim_off)
            }
        }
    
        Scaffold(
            topBar = {
                TopAppBar(
                    title = { Text(stringResource(R.string.settings_power_title), fontWeight = FontWeight.Bold) },
                    navigationIcon = {
                        FilledTonalIconButton(
                            onClick = onBackClicked,
                            colors = IconButtonDefaults.filledTonalIconButtonColors(
                                containerColor = MaterialTheme.colorScheme.surfaceContainer,
                                contentColor = MaterialTheme.colorScheme.onSurfaceVariant
                            )
                        ) {
                            Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = stringResource(R.string.settings_back))
                        }
                    },
                    colors = TopAppBarDefaults.topAppBarColors(
                        containerColor = MaterialTheme.colorScheme.background
                    )
                )
            }
        ) { padding ->
            Column(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(padding)
                    .verticalScroll(rememberScrollState())
                    .padding(16.dp),
                verticalArrangement = Arrangement.spacedBy(16.dp)
            ) {
                SettingsGroup(title = stringResource(R.string.settings_power_title)) {
    
                    val powerManager = context.getSystemService(Context.POWER_SERVICE) as PowerManager
                    val lifecycleOwner = LocalLifecycleOwner.current
    
                    var isIgnoringOptimizations by remember {
                        mutableStateOf(powerManager.isIgnoringBatteryOptimizations(context.packageName))
                    }
    
                    DisposableEffect(lifecycleOwner) {
                        val observer = LifecycleEventObserver { _, event ->
                            if (event == Lifecycle.Event.ON_RESUME) {
                                isIgnoringOptimizations = powerManager.isIgnoringBatteryOptimizations(context.packageName)
                            }
                        }
                        lifecycleOwner.lifecycle.addObserver(observer)
                        onDispose {
                            lifecycleOwner.lifecycle.removeObserver(observer)
                        }
                    }
    
                    SettingsToggleRow(
                        text = stringResource(R.string.settings_power_ignore_optimizations),
                        summary = stringResource(R.string.settings_power_ignore_optimizations_desc),
                        icon = Icons.Rounded.BatteryChargingFull,
                        checked = isIgnoringOptimizations,
                        onCheckedChange = { newState ->
                            if (newState && !isIgnoringOptimizations) {
                                val intent = Intent().apply {
                                    action = Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS
                                    data = "package:${context.packageName}".toUri()
                                }
                                context.startActivity(intent)
                            } else if (!newState && isIgnoringOptimizations) {
                                val intent = Intent().apply {
                                    action = Settings.ACTION_APPLICATION_DETAILS_SETTINGS
                                    data = "package:${context.packageName}".toUri()
                                }
                                context.startActivity(intent)
                            }
                        }
                    )
    
                    HorizontalDivider(modifier = Modifier.padding(vertical = 8.dp))
    
                    SettingsClickableRow(
                        text = stringResource(R.string.settings_power_auto_dim),
                        icon = Icons.Rounded.BrightnessLow,
                        summary = getDimDelaySummary(currentDimDelay),
                        onClick = { showAutoDimDialog = true }
                    )
    
                    SettingsToggleRow(
                        text = stringResource(R.string.settings_power_lock_input),
                        summary = stringResource(R.string.settings_power_lock_input_desc),
                        icon = Icons.Rounded.Lock,
                        checked = lockInput,
                        onCheckedChange = {
                            lockInput = it
                            SettingsManager.saveLockInputOnDim(context, it)
                        }
                    )
                }
    
                SettingsGroup(title = stringResource(R.string.settings_behavior_title)) {
                    SettingsToggleRow(
                        text = stringResource(R.string.settings_power_background_streaming),
                        summary = stringResource(R.string.settings_power_background_streaming_desc),
                        icon = Icons.Rounded.PictureInPicture,
                        checked = backgroundStreaming,
                        onCheckedChange = {
                            backgroundStreaming = it
                            SettingsManager.saveBackgroundStreaming(context, it)
                        }
                    )
    
                    SettingsToggleRow(
                        text = stringResource(R.string.settings_power_allow_reconnects),
                        summary = stringResource(R.string.settings_power_allow_reconnects_desc),
                        icon = Icons.Rounded.Sync,
                        checked = allowReconnects,
                        onCheckedChange = {
                            allowReconnects = it
                            SettingsManager.saveAllowReconnects(context, it)
                        }
                    )
    
                    SettingsGroup(title = stringResource(R.string.settings_network_title)) {
                        SettingsClickableRow(
                            text = stringResource(R.string.settings_port_title),
                            summary = stringResource(R.string.settings_port_summary),
                            icon = Icons.Rounded.SettingsEthernet,
                            subSummary = currentPort.toString(),
                            onClick = { showPortDialog = true }
                        )
                    }
                }
            }
        }
    
        if (showAutoDimDialog) {
            AutoDimDialog(
                currentDelay = currentDimDelay,
                onDismiss = { showAutoDimDialog = false },
                onDelaySelected = { newDelay ->
                    currentDimDelay = newDelay
                    SettingsManager.saveAutoDimDelay(context, newDelay)
                }
            )
        }
        if (showPortDialog) {
            PortSettingDialog(
                currentPort = currentPort,
                onDismiss = { showPortDialog = false },
                onSave = { newPort ->
                    currentPort = newPort
                    SettingsManager.savePort(context, newPort)
    
                    val intent = Intent(context, Cam::class.java).apply {
                        action = "set_http_port"
                        putExtra("port", newPort)
                    }
                    context.startService(intent)
                }
            )
        }
    }
    
    @Composable
    fun SettingsToggleRow(
        text: String,
        summary: String,
        icon: ImageVector,
        checked: Boolean,
        onCheckedChange: (Boolean) -> Unit
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .clickable { onCheckedChange(!checked) }
                .clip(RoundedCornerShape(8.dp))
                .padding(vertical = 8.dp, horizontal = 4.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Icon(icon, contentDescription = text, modifier = Modifier.padding(end = 16.dp), tint = MaterialTheme.colorScheme.onSurfaceVariant)
            Column(modifier = Modifier.weight(1f)) {
                Text(text, style = MaterialTheme.typography.bodyLarge)
                Text(
                    text = summary,
                    style = MaterialTheme.typography.bodyMedium,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
            AnimatedSystemSwitch(
                checked = checked,
                onCheckedChange = onCheckedChange
            )
        }
    }
    


================================================================================
FICHIER : \AndroidStudioProjects\RemoteCam-Enhanced\app\src\main\java\com\samsung\android\scan3d\screens\SettingsScreen.kt
================================================================================
    package com.samsung.android.scan3d.screens
    
    import androidx.appcompat.app.AppCompatDelegate
    import androidx.compose.foundation.layout.Arrangement
    import androidx.compose.foundation.layout.Column
    import androidx.compose.foundation.layout.fillMaxSize
    import androidx.compose.foundation.layout.padding
    import androidx.compose.foundation.rememberScrollState
    import androidx.compose.foundation.verticalScroll
    import androidx.compose.material.icons.Icons
    import androidx.compose.material.icons.automirrored.filled.ArrowBack
    import androidx.compose.material.icons.filled.Info
    import androidx.compose.material.icons.filled.WbSunny
    import androidx.compose.material.icons.rounded.*
    import androidx.compose.material3.*
    import androidx.compose.runtime.*
    import androidx.compose.ui.Modifier
    import androidx.compose.ui.platform.LocalContext
    import androidx.compose.ui.res.stringResource
    import androidx.compose.ui.unit.dp
    import androidx.core.os.LocaleListCompat
    import com.samsung.android.scan3d.R
    import com.samsung.android.scan3d.fragments.*
    import com.samsung.android.scan3d.ui.theme.updateAppMonet
    import com.samsung.android.scan3d.ui.theme.updateAppTheme
    import com.samsung.android.scan3d.util.SettingsManager
    import com.samsung.android.scan3d.CameraActivity
    import androidx.compose.runtime.mutableIntStateOf
    import androidx.compose.ui.text.font.FontWeight
    import androidx.compose.material3.FilledTonalIconButton
    import androidx.compose.material3.IconButtonDefaults
    
    @OptIn(ExperimentalMaterial3Api::class)
    @Composable
    fun SettingsScreen(
        onBackClicked: () -> Unit,
        onNavigateToAdditionalSettings: () -> Unit,
        onNavigateToPowerSettings: () -> Unit
    ) {
        val context = LocalContext.current
        val activity = context as? CameraActivity
    
        var showAboutDialog by remember { mutableStateOf(false) }
        var showLanguageDialog by remember { mutableStateOf(false) }
    
        var currentTheme: Int by remember { mutableIntStateOf(SettingsManager.loadThemeMode(context)) }
        var dynamicColor: Boolean by remember { mutableStateOf(SettingsManager.loadMonetEnabled(context)) }
        var keepScreenOn: Boolean by remember { mutableStateOf(SettingsManager.loadKeepScreenOn(context)) }
        var currentLanguage: String by remember { mutableStateOf(SettingsManager.loadLanguage(context)) }
    
        Scaffold(
            topBar = {
                TopAppBar(
                    title = { Text(stringResource(R.string.settings_title), fontWeight = FontWeight.Bold) },
                    navigationIcon = {
                        FilledTonalIconButton(
                            onClick = onBackClicked,
                            colors = IconButtonDefaults.filledTonalIconButtonColors(
                                containerColor = MaterialTheme.colorScheme.surfaceContainer,
                                contentColor = MaterialTheme.colorScheme.onSurfaceVariant
                            )
                        ) {
                            Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = stringResource(R.string.settings_back))
                        }
                    },
                    colors = TopAppBarDefaults.topAppBarColors(
                        containerColor = MaterialTheme.colorScheme.background
                    )
                )
            }
        ) { padding ->
            Column(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(padding)
                    .verticalScroll(rememberScrollState())
                    .padding(16.dp),
                verticalArrangement = Arrangement.spacedBy(16.dp)
            ) {
                SettingsGroup(title = stringResource(R.string.settings_appearance)) {
                    ThemeOptionRow(
                        text = stringResource(R.string.settings_theme_auto),
                        icon = Icons.Rounded.SettingsSystemDaydream,
                        selected = currentTheme == SettingsManager.THEME_AUTO,
                        onClick = {
                            if (currentTheme != SettingsManager.THEME_AUTO) {
                                currentTheme = SettingsManager.THEME_AUTO
                                updateAppTheme(context, SettingsManager.THEME_AUTO)
                            }
                        }
                    )
                    ThemeOptionRow(
                        text = stringResource(R.string.settings_theme_light),
                        icon = Icons.Default.WbSunny,
                        selected = currentTheme == SettingsManager.THEME_LIGHT,
                        onClick = {
                            if (currentTheme != SettingsManager.THEME_LIGHT) {
                                currentTheme = SettingsManager.THEME_LIGHT
                                updateAppTheme(context, SettingsManager.THEME_LIGHT)
                            }
                        }
                    )
                    ThemeOptionRow(
                        text = stringResource(R.string.settings_theme_dark),
                        icon = Icons.Rounded.DarkMode,
                        selected = currentTheme == SettingsManager.THEME_DARK,
                        onClick = {
                            if (currentTheme != SettingsManager.THEME_DARK) {
                                currentTheme = SettingsManager.THEME_DARK
                                updateAppTheme(context, SettingsManager.THEME_DARK)
                            }
                        }
                    )
    
                    HorizontalDivider(modifier = Modifier.padding(vertical = 8.dp))
    
                    SettingsToggleRow(
                        text = stringResource(R.string.settings_monet),
                        icon = Icons.Rounded.Palette,
                        checked = dynamicColor,
                        onCheckedChange = {
                            dynamicColor = it
                            updateAppMonet(context, it)
                        }
                    )
                }
    
                SettingsGroup(title = stringResource(R.string.settings_behavior_title)) {
                    SettingsToggleRow(
                        text = stringResource(R.string.settings_keep_screen_on),
                        icon = Icons.Rounded.Visibility,
                        checked = keepScreenOn,
                        onCheckedChange = {
                            keepScreenOn = it
                            SettingsManager.saveKeepScreenOn(context, it)
                        }
                    )
                    HorizontalDivider(modifier = Modifier.padding(vertical = 8.dp))
                    val langSummary = when (currentLanguage) {
                        SettingsManager.LANG_EN -> stringResource(R.string.settings_lang_en)
                        SettingsManager.LANG_FR -> stringResource(R.string.settings_lang_fr)
                        SettingsManager.LANG_HU -> stringResource(R.string.settings_lang_hu)
                        SettingsManager.LANG_PT -> stringResource(R.string.settings_lang_pt_br)
                        else -> stringResource(R.string.settings_lang_auto)
                    }
                    SettingsClickableRow(
                        text = stringResource(R.string.settings_language),
                        icon = Icons.Rounded.Language,
                        summary = langSummary,
                        onClick = { showLanguageDialog = true }
                    )
                }
    
                SettingsGroup(title = stringResource(R.string.settings_additional_title)) {
                    SettingsClickableRow(
                        text = stringResource(R.string.settings_camera_title),
                        icon = Icons.Rounded.CameraAlt,
                        onClick = onNavigateToAdditionalSettings
                    )
    
                    SettingsClickableRow(
                        text = stringResource(R.string.settings_power_title),
                        icon = Icons.Rounded.Power,
                        onClick = onNavigateToPowerSettings
                    )
                }
    
                SettingsGroup(title = stringResource(R.string.settings_app_title)) {
                    SettingsClickableRow(
                        text = stringResource(R.string.settings_about_title),
                        icon = Icons.Default.Info,
                        onClick = { showAboutDialog = true }
                    )
                }
            }
        }
    
        if (showAboutDialog) {
            AboutDialog(onDismiss = { showAboutDialog = false })
        }
    
        if (showLanguageDialog) {
            LanguageDialog(
                currentLanguage = currentLanguage,
                onDismiss = { showLanguageDialog = false },
                onLanguageSelected = { newLang ->
                    showLanguageDialog = false
                    if (currentLanguage != newLang) {
                        SettingsManager.saveLanguage(context, newLang)
                        val appLocale = LocaleListCompat.forLanguageTags(if (newLang == SettingsManager.LANG_AUTO) "" else newLang)
                        activity?.isRestarting = true
                        AppCompatDelegate.setApplicationLocales(appLocale)
                    }
                }
            )
        }
    }
    


================================================================================
FICHIER : \AndroidStudioProjects\RemoteCam-Enhanced\app\src\main\java\com\samsung\android\scan3d\serv\Cam.kt
================================================================================
    package com.samsung.android.scan3d.serv
    
    import android.app.Notification
    import android.app.NotificationChannel
    import android.app.NotificationManager
    import android.app.PendingIntent
    import android.app.PendingIntent.FLAG_IMMUTABLE
    import android.app.PendingIntent.FLAG_UPDATE_CURRENT
    import android.app.Service
    import android.content.Intent
    import android.os.IBinder
    import android.util.Log
    import android.view.Surface
    import androidx.core.app.NotificationCompat
    import com.samsung.android.scan3d.CameraActivity
    import com.samsung.android.scan3d.R
    import com.samsung.android.scan3d.ViewState
    import com.samsung.android.scan3d.http.HttpService
    import com.samsung.android.scan3d.util.SettingsManager
    import kotlinx.coroutines.CoroutineScope
    import kotlinx.coroutines.Dispatchers
    import kotlinx.coroutines.Job
    import kotlinx.coroutines.launch
    import kotlin.coroutines.CoroutineContext
    
    class Cam : Service(), CoroutineScope {
        var engine: CamEngine? = null
        var http: HttpService? = null
        // Renamed to follow Kotlin property naming conventions.
        private val channelId = "REMOTE_CAM"
        private val job = Job()
        override val coroutineContext: CoroutineContext
            get() = Dispatchers.Main + job
    
    
        override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
            Log.i("CAM", "onStartCommand " + intent?.action)
    
            if (intent == null) return START_STICKY
    
            if (http == null && intent.action != "start") {
                Log.w("CAM", "Service not yet initialized (http=null). Command '${intent.action}' ignored.")
                return START_STICKY
            }
    
            when (intent.action) {
                "start" -> {
                    if (http == null) {
                        val channel = NotificationChannel(
                            channelId,
                            channelId,
                            NotificationManager.IMPORTANCE_DEFAULT
                        )
                        channel.description = "RemoteCam run"
                        val notificationManager = getSystemService(NotificationManager::class.java)
                        notificationManager.createNotificationChannel(channel)
    
                        val notificationIntent = Intent(this, CameraActivity::class.java)
                        val pendingIntent = PendingIntent.getActivity(
                            this,
                            System.currentTimeMillis().toInt(),
                            notificationIntent,
                            FLAG_IMMUTABLE or FLAG_UPDATE_CURRENT
                        )
    
                        val intentKill = Intent(this, Cam::class.java)
                        intentKill.action = "KILL"
    
                        val pendingIntentKill = PendingIntent.getService(
                            this,
                            System.currentTimeMillis().toInt(),
                            intentKill,
                            FLAG_IMMUTABLE or FLAG_UPDATE_CURRENT
                        )
    
                        val builder =
                            NotificationCompat.Builder(this, channelId)
                                .setContentTitle(getString(R.string.notif_title))
                                .setContentText(getString(R.string.notif_text))
                                .setOngoing(true)
                                .setSmallIcon(R.drawable.ic_linked_camera)
                                .addAction(R.drawable.ic_close, getString(R.string.notif_kill), pendingIntentKill)
                                .setContentIntent(pendingIntent)
    
                        val notification: Notification = builder.build()
    
                        startForeground(123, notification)
    
                        http = HttpService(this)
                        engine?.http = http
    
                        launch(Dispatchers.IO) {
                            // Correct method to start the http service is start(), not main().
                            http?.start()
                        }
                    }
                }
    
                "onPause" -> {
                    val allowBackground = SettingsManager.loadBackgroundStreaming(this)
    
                    if (!allowBackground) {
                        engine?.insidePause = true
                        Log.i("CAM", "onPause: Background streaming disabled, pausing.")
                    } else {
                        engine?.insidePause = false
                        Log.i("CAM", "onPause: Background streaming enabled, continuing.")
                    }
                }
    
                "onResume" -> {
                    engine?.insidePause = false
                    Log.i("CAM", "onResume: Resuming.")
                }
    
                "start_engine_with_surface" -> {
                    // Using modern, type-safe getParcelable since minSdk is >= 33.
                    val surface: Surface? = intent.extras?.getParcelable("surface", Surface::class.java)
    
                    engine?.let {
                        if (it.insidePause) {
                            Log.i("CAM", "New surface received, forcing insidePause to false.")
                            it.insidePause = false
                        }
                    }
    
                    if (engine == null) {
                        Log.i("CAM", "CamEngine does not exist, creating...")
                        val targetFps = SettingsManager.loadTargetFps(this)
                        val antiFlicker = SettingsManager.loadAntiFlickerMode(this)
                        val noiseReduction = SettingsManager.loadNoiseReductionMode(this)
                        val stabilizationOff = SettingsManager.loadStabilizationOff(this)
    
                        engine = CamEngine(
                            context = this,
                            targetFps = targetFps,
                            currentAntiFlickerMode = antiFlicker,
                            currentNoiseReductionMode = noiseReduction,
                            isStabilizationOff = stabilizationOff
                        )
                        engine?.http = http
                    }
    
                    engine?.previewSurface = surface
                    engine?.initializeCamera()
                }
    
                "new_view_state" -> {
                    engine?.let { eng ->
                        val old = eng.viewState
                        // Using modern, type-safe getParcelable. The non-null assertion is kept from original code.
                        val new: ViewState = intent.extras?.getParcelable("data", ViewState::class.java)!!
                        eng.viewState = new
    
                        if (old.cameraId != new.cameraId ||
                            old.resolutionIndex != new.resolutionIndex ||
                            old.preview != new.preview)
                        {
                            Log.i("CAM", "Major change detected, restarting CamEngine.")
                            eng.restart()
                        }
                        else if (old.flash != new.flash || old.quality != new.quality) {
                            Log.i("CAM", "Minor change detected, updating request.")
                            eng.updateRepeatingRequest()
                        }
                    }
                }
    
                "preview_surface_destroyed" -> {
                    engine?.previewSurface = null
                    if (engine?.isShowingPreview == true) {
                        engine?.restart()
                    }
                }
    
                "scale_zoom" -> {
                    val scale = intent.getFloatExtra("scale_factor", 1.0f)
                    engine?.scaleZoom(scale)
                }
    
                "set_zoom_ratio" -> {
                    val ratio = intent.getFloatExtra("ratio", 0.0f)
                    engine?.setZoomRatio(ratio)
                }
    
                "volume_zoom_in" -> {
                    engine?.stepZoomIn()
                }
                "volume_zoom_out" -> {
                    engine?.stepZoomOut()
                }
                "volume_action_switch_cam" -> {
                    engine?.switchToNextCamera()
                }
                "volume_action_toggle_flash" -> {
                    engine?.toggleFlash()
                }
    
                "set_target_fps" -> {
                    val fps = intent.getIntExtra("fps", 30)
                    engine?.setTargetFps(fps)
                }
    
                "double_tap_action_switch_camera" -> {
                    engine?.switchToNextCamera()
                }
    
                "double_tap_action_toggle_zoom" -> {
                    engine?.toggleZoom()
                }
    
                "set_anti_flicker" -> {
                    val mode = intent.getIntExtra("mode", SettingsManager.ANTI_FLICKER_AUTO)
                    engine?.setAntiFlickerMode(mode)
                }
    
                "set_noise_reduction" -> {
                    val mode = intent.getIntExtra("mode", SettingsManager.NR_AUTO)
                    engine?.setNoiseReductionMode(mode)
                }
    
                "set_stabilization" -> {
                    val isOff = intent.getBooleanExtra("is_off", false)
                    engine?.setStabilizationOff(isOff)
                }
    
                "set_zoom_smoothing" -> {
                    val delay = intent.getIntExtra("delay", SettingsManager.SMOOTH_DELAY_NONE)
                    engine?.setZoomSmoothingDelay(delay)
                }
    
                "set_http_port" -> {
                    val newPort = intent.getIntExtra("port", SettingsManager.DEFAULT_PORT)
                    http?.restartServer(newPort)
    
                    val uiIntent = Intent("PORT_UPDATED").setPackage(packageName)
                    sendBroadcast(uiIntent)
                    engine?.restart()
                }
    
                "KILL", "stop" -> {
                    kill()
                }
    
                else -> {
                    Log.w("CAM", "Unknown or unhandled action: ${intent.action}")
                }
            }
    
            return START_STICKY
        }
    
        fun kill(){
            engine?.destroy()
            engine = null
            // Call the new public stop() method on the http service.
            http?.stop()
            http = null
    
            val intent = Intent("KILL_ACTIVITY").setPackage(packageName)
            sendBroadcast(intent)
    
            stopForeground(STOP_FOREGROUND_REMOVE)
            stopSelf()
        }
    
        override fun onBind(intent: Intent?): IBinder? {
            return null
        }
    
        override fun onDestroy() {
            super.onDestroy()
            Log.i("CAM", "OnDestroy")
            job.cancel()
            kill()
        }
    
        // Removed unused companion object.
    }
    


================================================================================
FICHIER : \AndroidStudioProjects\RemoteCam-Enhanced\app\src\main\java\com\samsung\android\scan3d\serv\CamEngine.kt
================================================================================
    package com.samsung.android.scan3d.serv
    
    import android.annotation.SuppressLint
    import android.content.Context
    import android.content.Intent
    import android.graphics.ImageFormat
    import android.graphics.Rect
    import android.hardware.camera2.*
    import android.hardware.camera2.params.OutputConfiguration
    import android.hardware.camera2.params.SessionConfiguration
    import android.media.ImageReader
    import android.os.Handler
    import android.os.HandlerThread
    import android.os.Parcelable
    import android.util.Log
    import android.util.Range
    import android.util.Size
    import android.view.Surface
    import com.samsung.android.scan3d.ViewState
    import com.samsung.android.scan3d.http.HttpService
    import com.samsung.android.scan3d.util.Selector
    import com.samsung.android.scan3d.util.SettingsManager
    import kotlinx.coroutines.CoroutineScope
    import kotlinx.coroutines.android.asCoroutineDispatcher
    import kotlinx.coroutines.launch
    import kotlinx.coroutines.suspendCancellableCoroutine
    import kotlinx.parcelize.Parcelize
    import java.util.concurrent.atomic.AtomicInteger
    import kotlin.coroutines.resume
    import kotlin.coroutines.resumeWithException
    import kotlin.coroutines.suspendCoroutine
    import kotlinx.coroutines.Job
    import kotlinx.coroutines.delay
    import kotlinx.coroutines.isActive
    import java.util.concurrent.Executor
    
    
    class CamEngine(
        val context: Context,
        private var targetFps: Int,
        private var currentAntiFlickerMode: Int,
        private var currentNoiseReductionMode: Int,
        private var isStabilizationOff: Boolean
    ) {
    
        var http: HttpService? = null
        var resW = 1280
        var resH = 720
    
        var insidePause = false
        var isShowingPreview: Boolean = false
    
        private var cameraManager: CameraManager = context.getSystemService(Context.CAMERA_SERVICE) as CameraManager
        private var cameraList: List<Selector.SensorDesc> = Selector.enumerateCameras(cameraManager)
    
        val camOutPutFormat = ImageFormat.JPEG
    
        @Volatile
        private var isInitializing = false
        @Volatile
        private var restartPending = false
    
        private var lastQuickUpdateTime = 0L
        private val quickUpdateIntervalMs = 500L
    
        private var currentSmoothingDelay: Int = SettingsManager.loadZoomSmoothingDelay(context)
        private var zoomAnimatorJob: Job? = null
        private val zoomAnimationSteps = 10 // Number of steps for the animation
    
        // --- CAMERA VARIABLES (will be initialized later) ---
        private var maxZoom: Float = 1.0f
        private var currentZoomRatio: Float = 1.0f
        private lateinit var activeArraySize: Rect
        private var captureRequestBuilder: CaptureRequest.Builder? = null
        private var sessionCallback: CameraCaptureSession.CaptureCallback? = null
        private var hasFlash: Boolean = false
        private lateinit var fpsRanges: Array<Range<Int>>
        private var zoomToggleState: Boolean = false
        private var availableAntiFlickerModes: IntArray = intArrayOf()
        private var availableNoiseReductionModes: IntArray = intArrayOf()
        private var availableOisModes: IntArray = intArrayOf()
        private var availableEisModes: IntArray = intArrayOf()
        private lateinit var characteristics: CameraCharacteristics
        private lateinit var sizes: List<Size>
        private var sensorOrientation: Int = 0
    
        private val defaultCameraId = cameraList.firstOrNull()?.cameraId ?: "0"
        var viewState: ViewState = SettingsManager.loadViewState(context, defaultCameraId)
    
        private lateinit var imageReader: ImageReader
        private val cameraThread = HandlerThread("CameraThread").apply { start() }
        private val cameraHandler = Handler(cameraThread.looper)
        private val cameraScope = CoroutineScope(cameraHandler.asCoroutineDispatcher())
        private lateinit var camera: CameraDevice
        var previewSurface: Surface? = null
        private var session: CameraCaptureSession? = null
    
        private fun stopRunning() {
            zoomAnimatorJob?.cancel()
            if (session != null) {
                Log.i("CAMERA", "close")
                try {
                    session!!.stopRepeating()
                    session!!.close()
                } catch (e: Exception) {
                    Log.e("CamEngine", "Error while closing session", e)
                }
                session = null
                try {
                    if (::camera.isInitialized) camera.close()
                    if (::imageReader.isInitialized) imageReader.close()
                } catch (e: Exception) {
                    Log.e("CamEngine", "Error closing camera/imageReader", e)
                }
            }
        }
    
        fun restart() {
            cameraScope.launch {
                if (isInitializing) {
                    Log.w("CamEngine", "Initialization in progress, queuing restart.")
                    restartPending = true
                    return@launch
                }
                isInitializing = true
                try {
                    stopRunning()
                    initializeCameraInternal()
                } catch (e: Exception) {
                    Log.e("CamEngine", "Failed to restart camera", e)
                } finally {
                    isInitializing = false
                    if (restartPending) {
                        Log.i("CamEngine", "Executing queued restart.")
                        restartPending = false
                        restart()
                    }
                }
            }
        }
    
        @SuppressLint("MissingPermission")
        private suspend fun openCamera(manager: CameraManager, cameraId: String, handler: Handler? = null): CameraDevice = suspendCancellableCoroutine { cont ->
            try {
                manager.openCamera(cameraId, object : CameraDevice.StateCallback() {
                    override fun onOpened(device: CameraDevice) {
                        // --- FIXED ---
                        if (cont.context.isActive) {
                            cont.resume(device)
                        } else {
                            device.close()
                        }
                    }
    
                    override fun onDisconnected(device: CameraDevice) {
                        Log.w("CamEngine", "Camera $cameraId has been disconnected")
                    }
    
                    override fun onError(device: CameraDevice, error: Int) {
                        val msg = when(error) { else -> "Unknown" }
                        val exc = RuntimeException("Camera $cameraId error: ($error) $msg")
                        Log.e("CamEngine", exc.message, exc)
                        // --- FIXED ---
                        if (cont.context.isActive) {
                            cont.resumeWithException(exc)
                        }
                    }
                }, handler)
            } catch (e: Exception) {
                Log.e("CamEngine", "Synchronous error during openCamera", e)
                // --- FIXED ---
                if (cont.context.isActive) {
                    cont.resumeWithException(e)
                }
            }
        }
    
        private suspend fun createCaptureSession(device: CameraDevice, targets: List<Surface>, handler: Handler? = null): CameraCaptureSession = suspendCoroutine { cont ->
            val stateCallback = object : CameraCaptureSession.StateCallback() {
                override fun onConfigured(session: CameraCaptureSession) {
                    if (cont.context.isActive) {
                        cont.resume(session)
                    } else {
                        session.close()
                    }
                }
    
                override fun onConfigureFailed(session: CameraCaptureSession) {
                    val exc = RuntimeException("Camera ${device.id} session configuration failed")
                    Log.e("CamEngine", exc.message, exc)
                    // --- FIXED ---
                    if (cont.context.isActive) {
                        cont.resumeWithException(exc)
                    }
                }
            }
    
            try {
                // No if/else needed, assuming minSdk >= 28 (P)
                val outputConfigs = targets.map { OutputConfiguration(it) }
                // Convert Handler to Executor
                val executor = Executor { runnable -> handler?.post(runnable) ?: runnable.run() }
                val sessionConfig = SessionConfiguration(
                    SessionConfiguration.SESSION_REGULAR,
                    outputConfigs,
                    executor,
                    stateCallback
                )
                device.createCaptureSession(sessionConfig)
    
            } catch (e: Exception) {
                Log.e("CamEngine", "Synchronous error during createCaptureSession", e)
                // --- FIXED ---
                if (cont.context.isActive) {
                    cont.resumeWithException(e)
                }
            }
        }
    
        private suspend fun initializeCameraInternal() {
            Log.i("CAMERA", "initializeCameraInternal")
            stopRunning()
    
            if (cameraList.none { it.cameraId == viewState.cameraId }) {
                Log.w("CamEngine", "Saved camera (${viewState.cameraId}) not found. Reverting to default camera.")
                viewState = viewState.copy(cameraId = defaultCameraId)
                SettingsManager.saveSettings(context, viewState)
            }
    
            try {
                characteristics = cameraManager.getCameraCharacteristics(viewState.cameraId)
                sensorOrientation = characteristics.get(CameraCharacteristics.SENSOR_ORIENTATION) ?: 0
                sizes = characteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP)!!.getOutputSizes(camOutPutFormat).reversed()
                hasFlash = characteristics.get(CameraCharacteristics.FLASH_INFO_AVAILABLE) ?: false
                fpsRanges = characteristics.get(CameraCharacteristics.CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES) ?: arrayOf()
                availableAntiFlickerModes = characteristics.get(CameraCharacteristics.CONTROL_AE_AVAILABLE_ANTIBANDING_MODES) ?: intArrayOf()
                availableNoiseReductionModes = characteristics.get(CameraCharacteristics.NOISE_REDUCTION_AVAILABLE_NOISE_REDUCTION_MODES) ?: intArrayOf()
                availableOisModes = characteristics.get(CameraCharacteristics.LENS_INFO_AVAILABLE_OPTICAL_STABILIZATION) ?: intArrayOf()
                availableEisModes = characteristics.get(CameraCharacteristics.CONTROL_AVAILABLE_VIDEO_STABILIZATION_MODES) ?: intArrayOf()
                maxZoom = characteristics.get(CameraCharacteristics.SCALER_AVAILABLE_MAX_DIGITAL_ZOOM) ?: 1.0f
                activeArraySize = characteristics.get(CameraCharacteristics.SENSOR_INFO_ACTIVE_ARRAY_SIZE)!!
            } catch (e: Exception) {
                Log.e("CamEngine", "Could not get characteristics for ${viewState.cameraId}. Aborting.", e)
                return
            }
    
            if (sizes.isEmpty()) {
                Log.e("CamEngine", "No JPEG sizes found for ${viewState.cameraId}")
                return
            }
    
            val isFirstSetup = (viewState.resolutionIndex == null)
            val isIndexInvalid = !isFirstSetup && viewState.resolutionIndex!! >= sizes.size
    
            if (isFirstSetup || isIndexInvalid) {
                if (isFirstSetup) {
                    Log.i("CamEngine", "First run detected. Applying default settings (1280x720, 1% quality).")
                    val targetWidth = 1280
                    val targetHeight = 720
                    var targetIndex = sizes.indexOfFirst { it.width == targetWidth && it.height == targetHeight }
                    if (targetIndex == -1) {
                        Log.w("CamEngine", "Resolution 1280x720 does not exist, falling back to <= 720p.")
                        targetIndex = sizes.indexOfLast { it.height <= 720 }.takeIf { it != -1 } ?: (sizes.size - 1)
                    }
                    viewState = viewState.copy(resolutionIndex = targetIndex, quality = 1)
                } else {
                    Log.w("CamEngine", "Invalid resolution index. Resetting to a size <= 720p.")
                    viewState = viewState.copy(resolutionIndex = sizes.indexOfLast { it.height <= 720 }.takeIf { it != -1 } ?: (sizes.size - 1))
                }
                SettingsManager.saveSettings(context, viewState)
            }
    
            if (!hasFlash && viewState.flash) {
                viewState = viewState.copy(flash = false)
                SettingsManager.saveSettings(context, viewState)
            }
    
            val selectedSize = sizes[viewState.resolutionIndex!!]
            resW = selectedSize.width
            resH = selectedSize.height
    
            val showLiveSurface = viewState.preview && !insidePause && previewSurface != null
            isShowingPreview = showLiveSurface
    
            try {
                camera = openCamera(cameraManager, viewState.cameraId, cameraHandler)
            } catch (e: Exception) {
                Log.e("CamEngine", "Could not open camera ${viewState.cameraId}", e)
                return
            }
    
            imageReader = ImageReader.newInstance(resW, resH, camOutPutFormat, 4)
            var targets = listOf(imageReader.surface)
            if (showLiveSurface) {
                if (previewSurface?.isValid == true) {
                    targets = targets.plus(previewSurface!!)
                } else {
                    Log.w("CamEngine", "Preview surface is invalid, continuing without it.")
                    isShowingPreview = false
                }
            }
    
            try {
                session = createCaptureSession(camera, targets, cameraHandler)
            } catch (e: Exception) {
                Log.e("CamEngine", "Could not create capture session", e)
                return
            }
    
            captureRequestBuilder = camera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW)
            if (showLiveSurface && previewSurface?.isValid == true) {
                captureRequestBuilder!!.addTarget(previewSurface!!)
            }
            captureRequestBuilder!!.addTarget(imageReader.surface)
    
            currentZoomRatio = SettingsManager.loadZoomRatio(context).coerceIn(1.0f, maxZoom)
            zoomToggleState = (currentZoomRatio > 1.01f)
    
            applyFlash(captureRequestBuilder!!)
            applyZoom(captureRequestBuilder!!)
            applyFps(captureRequestBuilder!!)
            applyStabilization(captureRequestBuilder!!)
            applyNoiseReduction(captureRequestBuilder!!)
            applyAntiFlicker(captureRequestBuilder!!)
            captureRequestBuilder!!.set(CaptureRequest.JPEG_QUALITY, viewState.quality.toByte())
    
            var lastTime = System.currentTimeMillis()
            val aquired = AtomicInteger(0)
    
            sessionCallback = object : CameraCaptureSession.CaptureCallback() {
                override fun onCaptureCompleted(session: CameraCaptureSession, request: CaptureRequest, result: TotalCaptureResult) {
                    super.onCaptureCompleted(session, request, result)
                    var lastImg: android.media.Image? = try {
                        imageReader.acquireNextImage()
                    } catch (e: Exception) {
                        Log.w("CamEngine", "Failed to acquire next image", e)
                        null
                    }
                    if (aquired.get() > 1 && lastImg != null) {
                        lastImg.close()
                        lastImg = null
                    }
                    val img = lastImg ?: return
                    aquired.incrementAndGet()
    
                    val acquisitionTime = System.currentTimeMillis()
                    val delta = acquisitionTime - lastTime
                    lastTime = acquisitionTime
    
                    val buffer = img.planes[0].buffer
                    val bytes = ByteArray(buffer.remaining()).apply { buffer.get(this) }
                    if (viewState.stream && !insidePause) {
                        http?.sendFrame(bytes)
                    }
                    img.close()
                    aquired.decrementAndGet()
    
                    if (delta > 0) {
                        val rate = (bytes.size.toLong() * 1000) / (delta * 1024)
                        val quickData = DataQuick(ms = delta.toInt(), rateKbs = rate.toInt())
                        if (acquisitionTime - lastQuickUpdateTime > quickUpdateIntervalMs) {
                            updateViewQuick(quickData)
                            lastQuickUpdateTime = acquisitionTime
                        }
                    }
                }
            }
    
            session?.setRepeatingRequest(captureRequestBuilder!!.build(), sessionCallback!!, cameraHandler)
            updateView()
        }
    
        fun initializeCamera() {
            restart()
        }
    
        fun destroy() {
            stopRunning()
            cameraThread.quitSafely()
        }
    
        fun updateView() {
            if (!::sizes.isInitialized) return
            val resIndex = viewState.resolutionIndex ?: return
            val sensor = cameraList.find { it.cameraId == viewState.cameraId } ?: return
            val parcelableSizes = sizes.map { ParcelableSize(it.width, it.height) }
    
            val dataToSend = Data(
                sensors = cameraList,
                sensorSelected = sensor,
                resolutions = parcelableSizes,
                resolutionSelected = resIndex,
                currentZoom = currentZoomRatio,
                maxZoom = maxZoom,
                hasFlash = hasFlash,
                quality = viewState.quality,
                flashState = viewState.flash,
                sensorOrientation = sensorOrientation
            )
    
            val intent = Intent("UpdateFromCameraEngine").setPackage(context.packageName)
            intent.putExtra("data", dataToSend)
            context.sendBroadcast(intent)
        }
    
        fun updateViewQuick(dq: DataQuick) {
            val intent = Intent("UpdateFromCameraEngine").setPackage(context.packageName)
            intent.putExtra("dataQuick", dq)
            context.sendBroadcast(intent)
        }
    
        private fun applyZoom(builder: CaptureRequest.Builder) {
            if (!::activeArraySize.isInitialized) return
            val zoomWidth = (activeArraySize.width() / currentZoomRatio).toInt()
            val zoomHeight = (activeArraySize.height() / currentZoomRatio).toInt()
            val centerX = activeArraySize.width() / 2
            val centerY = activeArraySize.height() / 2
            val cropRect = Rect(centerX - zoomWidth / 2, centerY - zoomHeight / 2, centerX + zoomWidth / 2, centerY + zoomHeight / 2)
            builder.set(CaptureRequest.SCALER_CROP_REGION, cropRect)
        }
    
        fun scaleZoom(scaleFactor: Float) {
            setZoom(currentZoomRatio * scaleFactor)
        }
    
        fun setZoomRatio(ratio: Float) {
            if (!::activeArraySize.isInitialized) return
            setZoom(1.0f + (maxZoom - 1.0f) * ratio.coerceIn(0.0f, 1.0f))
        }
    
        private fun setZoom(zoomRatio: Float) {
            if (session == null || captureRequestBuilder == null || !::camera.isInitialized) return
            val newZoom = zoomRatio.coerceIn(1.0f, maxZoom)
            if (newZoom == currentZoomRatio) return
            currentZoomRatio = newZoom
            zoomToggleState = (currentZoomRatio > 1.01f)
            applyZoom(captureRequestBuilder!!)
            try {
                session?.setRepeatingRequest(captureRequestBuilder!!.build(), sessionCallback!!, cameraHandler)
                if (SettingsManager.loadRememberSettings(context) && SettingsManager.loadRememberZoom(context)) {
                    SettingsManager.saveZoomRatio(context, currentZoomRatio)
                }
                updateView()
            } catch (e: Exception) {
                Log.e("CamEngine", "Failed to update zoom", e)
            }
        }
    
        private fun getZoomStep(): Float {
            return (maxZoom - 1.0f) * 0.05f
        }
    
        fun stepZoomIn() {
            val step = getZoomStep()
            animateZoom((currentZoomRatio + step).coerceIn(1.0f, maxZoom))
        }
    
        fun stepZoomOut() {
            val step = getZoomStep()
            animateZoom((currentZoomRatio - step).coerceIn(1.0f, maxZoom))
        }
    
        private fun applyFlash(builder: CaptureRequest.Builder) {
            if (!hasFlash) return
            builder.set(CaptureRequest.FLASH_MODE, if (viewState.flash) CaptureRequest.FLASH_MODE_TORCH else CaptureRequest.FLASH_MODE_OFF)
        }
    
        private fun applyFps(builder: CaptureRequest.Builder) {
            if (fpsRanges.isEmpty()) return
            val selectedRange = fpsRanges.find { it.lower == targetFps && it.upper == targetFps }
                ?: fpsRanges.filter { it.upper >= targetFps && it.lower <= targetFps }.minByOrNull { it.upper }
                ?: fpsRanges.maxByOrNull { it.upper }
            if (selectedRange != null) {
                builder.set(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE, selectedRange)
            }
        }
    
        private fun applyStabilization(builder: CaptureRequest.Builder) {
            if (isStabilizationOff) {
                if (availableEisModes.contains(CaptureRequest.CONTROL_VIDEO_STABILIZATION_MODE_OFF)) builder.set(CaptureRequest.CONTROL_VIDEO_STABILIZATION_MODE, CaptureRequest.CONTROL_VIDEO_STABILIZATION_MODE_OFF)
                if (availableOisModes.contains(CaptureRequest.LENS_OPTICAL_STABILIZATION_MODE_OFF)) builder.set(CaptureRequest.LENS_OPTICAL_STABILIZATION_MODE, CaptureRequest.LENS_OPTICAL_STABILIZATION_MODE_OFF)
            } else {
                if (availableEisModes.contains(CaptureRequest.CONTROL_VIDEO_STABILIZATION_MODE_ON)) builder.set(CaptureRequest.CONTROL_VIDEO_STABILIZATION_MODE, CaptureRequest.CONTROL_VIDEO_STABILIZATION_MODE_ON)
                if (availableOisModes.contains(CaptureRequest.LENS_OPTICAL_STABILIZATION_MODE_ON)) builder.set(CaptureRequest.LENS_OPTICAL_STABILIZATION_MODE, CaptureRequest.LENS_OPTICAL_STABILIZATION_MODE_ON)
            }
        }
    
        private fun applyNoiseReduction(builder: CaptureRequest.Builder) {
            val mode = when (currentNoiseReductionMode) {
                SettingsManager.NR_OFF -> CaptureRequest.NOISE_REDUCTION_MODE_OFF
                SettingsManager.NR_LOW -> CaptureRequest.NOISE_REDUCTION_MODE_FAST
                SettingsManager.NR_HIGH -> CaptureRequest.NOISE_REDUCTION_MODE_HIGH_QUALITY
                else -> CaptureRequest.NOISE_REDUCTION_MODE_FAST
            }
            if (availableNoiseReductionModes.contains(mode)) builder.set(CaptureRequest.NOISE_REDUCTION_MODE, mode)
        }
    
        private fun applyAntiFlicker(builder: CaptureRequest.Builder) {
            val mode = when (currentAntiFlickerMode) {
                SettingsManager.ANTI_FLICKER_OFF -> CaptureRequest.CONTROL_AE_ANTIBANDING_MODE_OFF
                SettingsManager.ANTI_FLICKER_50HZ -> CaptureRequest.CONTROL_AE_ANTIBANDING_MODE_50HZ
                SettingsManager.ANTI_FLICKER_60HZ -> CaptureRequest.CONTROL_AE_ANTIBANDING_MODE_60HZ
                else -> CaptureRequest.CONTROL_AE_ANTIBANDING_MODE_AUTO
            }
            if (availableAntiFlickerModes.contains(mode)) builder.set(CaptureRequest.CONTROL_AE_ANTIBANDING_MODE, mode)
        }
    
        fun updateRepeatingRequest() {
            if (session == null || captureRequestBuilder == null || !::camera.isInitialized) return
            applyFlash(captureRequestBuilder!!)
            applyNoiseReduction(captureRequestBuilder!!)
            applyAntiFlicker(captureRequestBuilder!!)
            captureRequestBuilder!!.set(CaptureRequest.JPEG_QUALITY, viewState.quality.toByte())
            try {
                session?.setRepeatingRequest(captureRequestBuilder!!.build(), sessionCallback!!, cameraHandler)
            } catch (e: Exception) {
                Log.e("CamEngine", "Failed 'light' update", e)
            }
        }
    
        fun setTargetFps(fps: Int) {
            if (fps == this.targetFps) return
            this.targetFps = fps
            SettingsManager.saveTargetFps(context, fps)
            restart()
        }
    
        fun setAntiFlickerMode(mode: Int) {
            if (mode == this.currentAntiFlickerMode) return
            this.currentAntiFlickerMode = mode
            SettingsManager.saveAntiFlickerMode(context, mode)
            updateRepeatingRequest()
        }
    
        fun setNoiseReductionMode(mode: Int) {
            if (mode == this.currentNoiseReductionMode) return
            this.currentNoiseReductionMode = mode
            SettingsManager.saveNoiseReductionMode(context, mode)
            updateRepeatingRequest()
        }
    
        fun setStabilizationOff(isOff: Boolean) {
            if (isOff == this.isStabilizationOff) return
            this.isStabilizationOff = isOff
            SettingsManager.saveStabilizationOff(context, isOff)
            restart()
        }
    
        fun switchToNextCamera() {
            val currentIndex = cameraList.indexOfFirst { it.cameraId == viewState.cameraId }
            val nextCameraId = cameraList[(currentIndex + 1) % cameraList.size].cameraId
            viewState = viewState.copy(cameraId = nextCameraId, flash = false, resolutionIndex = null)
            SettingsManager.saveSettings(context, viewState)
            restart()
        }
    
        fun toggleFlash() {
            if (session == null || !hasFlash) return
            val newFlashState = !viewState.flash
            viewState = viewState.copy(flash = newFlashState)
            SettingsManager.saveSettings(context, viewState)
            updateRepeatingRequest()
            updateView()
        }
    
        fun toggleZoom() {
            val newZoom = if (zoomToggleState) 1.0f else 2.0f.coerceAtMost(maxZoom)
            animateZoom(newZoom)
        }
    
        fun setZoomSmoothingDelay(delayMs: Int) {
            currentSmoothingDelay = delayMs
            SettingsManager.saveZoomSmoothingDelay(context, delayMs)
        }
    
        private fun animateZoom(targetZoom: Float) {
            zoomAnimatorJob?.cancel()
    
            if (currentSmoothingDelay == 0) {
                setZoom(targetZoom)
                return
            }
    
            zoomAnimatorJob = cameraScope.launch {
                val startZoom = currentZoomRatio
                val delayMs = currentSmoothingDelay.toLong()
    
                for (i in 1..zoomAnimationSteps) {
                    val progress = i.toFloat() / zoomAnimationSteps.toFloat()
                    val newZoom = startZoom + (targetZoom - startZoom) * progress
    
                    setZoom(newZoom)
    
                    delay(delayMs)
                }
                setZoom(targetZoom)
            }
        }
    
        companion object {
            @Parcelize data class ParcelableSize(val width: Int, val height: Int) : Parcelable {
                override fun toString(): String = "$width x $height"
            }
            @Parcelize data class Data(
                val sensors: List<Selector.SensorDesc>,
                val sensorSelected: Selector.SensorDesc,
                val resolutions: List<ParcelableSize>,
                val resolutionSelected: Int,
                val currentZoom: Float,
                val maxZoom: Float,
                val hasFlash: Boolean,
                val quality: Int,
                val flashState: Boolean,
                val sensorOrientation: Int
            ) : Parcelable
            @Parcelize data class DataQuick(val ms: Int, val rateKbs: Int) : Parcelable
        }
    }
    


================================================================================
FICHIER : \AndroidStudioProjects\RemoteCam-Enhanced\app\src\main\java\com\samsung\android\scan3d\ui\theme\Theme.kt
================================================================================
    package com.samsung.android.scan3d.ui.theme
    
    import android.app.Activity
    import android.content.Context
    import androidx.compose.foundation.isSystemInDarkTheme
    import androidx.compose.material3.MaterialTheme
    import androidx.compose.material3.darkColorScheme
    import androidx.compose.material3.dynamicDarkColorScheme
    import androidx.compose.material3.dynamicLightColorScheme
    import androidx.compose.material3.lightColorScheme
    import androidx.compose.runtime.Composable
    import androidx.compose.runtime.LaunchedEffect
    import androidx.compose.runtime.SideEffect
    import androidx.compose.runtime.getValue
    import androidx.compose.runtime.setValue
    import androidx.compose.ui.platform.LocalContext
    import androidx.compose.ui.platform.LocalView
    import androidx.core.view.WindowCompat
    import com.samsung.android.scan3d.util.SettingsManager
    import androidx.compose.runtime.mutableIntStateOf
    import androidx.compose.runtime.mutableStateOf
    
    private var AppThemeMode by mutableIntStateOf(SettingsManager.THEME_AUTO)
    private var AppMonetEnabled by mutableStateOf(true)
    
    fun updateAppTheme(context: Context, mode: Int) {
        AppThemeMode = mode
        SettingsManager.saveThemeMode(context, mode)
    }
    
    fun updateAppMonet(context: Context, enabled: Boolean) {
        AppMonetEnabled = enabled
        SettingsManager.saveMonetEnabled(context, enabled)
    }
    
    private val ExpressiveDarkColors = darkColorScheme(
        primary = androidx.compose.ui.graphics.Color(0xFFD0BCFF),
        secondary = androidx.compose.ui.graphics.Color(0xFFCCC2DC),
        tertiary = androidx.compose.ui.graphics.Color(0xFFEFB8C8),
        background = androidx.compose.ui.graphics.Color(0xFF1C1B1F),
        surface = androidx.compose.ui.graphics.Color(0xFF1C1B1F),
        onPrimary = androidx.compose.ui.graphics.Color(0xFF381E72),
        onSecondary = androidx.compose.ui.graphics.Color(0xFF332D41),
        onTertiary = androidx.compose.ui.graphics.Color(0xFF492532),
        onBackground = androidx.compose.ui.graphics.Color(0xFFE6E1E5),
        onSurface = androidx.compose.ui.graphics.Color(0xFFE6E1E5)
    )
    
    private val ExpressiveLightColors = lightColorScheme(
        primary = androidx.compose.ui.graphics.Color(0xFF6750A4),
        secondary = androidx.compose.ui.graphics.Color(0xFF625B71),
        tertiary = androidx.compose.ui.graphics.Color(0xFF7D5260),
        background = androidx.compose.ui.graphics.Color(0xFFFFFBFE),
        surface = androidx.compose.ui.graphics.Color(0xFFFFFBFE),
        onPrimary = androidx.compose.ui.graphics.Color(0xFFFFFFFF),
        onSecondary = androidx.compose.ui.graphics.Color(0xFFFFFFFF),
        onTertiary = androidx.compose.ui.graphics.Color(0xFFFFFFFF),
        onBackground = androidx.compose.ui.graphics.Color(0xFF1C1B1F),
        onSurface = androidx.compose.ui.graphics.Color(0xFF1C1B1F)
    )
    
    @Composable
    fun RemoteCamM3Theme(
        content: @Composable () -> Unit
    ) {
        val context = LocalContext.current
        LaunchedEffect(Unit) {
            AppThemeMode = SettingsManager.loadThemeMode(context)
            AppMonetEnabled = SettingsManager.loadMonetEnabled(context)
        }
        val darkTheme = when (AppThemeMode) {
            SettingsManager.THEME_LIGHT -> false
            SettingsManager.THEME_DARK -> true
            else -> isSystemInDarkTheme() // THEME_AUTO
        }
    
        val dynamicColor = AppMonetEnabled
    
        val colorScheme = when {
            dynamicColor -> {
                if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)
            }
            darkTheme -> ExpressiveDarkColors
            else -> ExpressiveLightColors
        }
    
        val view = LocalView.current
        if (!view.isInEditMode) {
            SideEffect {
                val window = (view.context as Activity).window
                WindowCompat.getInsetsController(window, view).isAppearanceLightStatusBars = !darkTheme
            }
        }
    
        MaterialTheme(
            colorScheme = colorScheme,
            content = content
        )
    }
    


================================================================================
FICHIER : \AndroidStudioProjects\RemoteCam-Enhanced\app\src\main\java\com\samsung\android\scan3d\util\ClipboardUtil.kt
================================================================================
    package com.samsung.android.scan3d.util
    
    import android.content.ClipData
    import android.content.Context
    
    object ClipboardUtil {
    
        fun copyToClipboard(context: Context?, label: String, text: String) {
            val clipboard = context?.getSystemService(Context.CLIPBOARD_SERVICE) as android.content.ClipboardManager
            val clip = ClipData.newPlainText(label, text)
            clipboard.setPrimaryClip(clip)
        }
    }


================================================================================
FICHIER : \AndroidStudioProjects\RemoteCam-Enhanced\app\src\main\java\com\samsung\android\scan3d\util\IpUtil.kt
================================================================================
    package com.samsung.android.scan3d.util
    
    import java.net.NetworkInterface
    import java.util.Collections
    
    object IpUtil {
    
        fun getLocalIpAddress(): String? {
            try {
                val interfaces: List<NetworkInterface> = Collections.list(NetworkInterface.getNetworkInterfaces())
                for (networkInterface in interfaces) {
                    val addresses = networkInterface.inetAddresses
                    for (address in addresses) {
                        if (!address.isLoopbackAddress && address.isSiteLocalAddress) {
                            return address.hostAddress
                        }
                    }
                }
            } catch (e: Exception) {
                e.printStackTrace()
            }
            return null
        }
    }


================================================================================
FICHIER : \AndroidStudioProjects\RemoteCam-Enhanced\app\src\main\java\com\samsung\android\scan3d\util\Selector.kt
================================================================================
    package com.samsung.android.scan3d.util
    
    import android.annotation.SuppressLint
    import android.graphics.ImageFormat
    import android.hardware.camera2.CameraCharacteristics
    import android.hardware.camera2.CameraManager
    import android.hardware.camera2.CameraMetadata
    import android.os.Parcelable
    import android.util.Log
    import kotlinx.parcelize.Parcelize
    import java.lang.Exception
    import kotlin.math.atan
    import kotlin.math.roundToInt
    
    object Selector {
        /** Helper class used as a data holder for each selectable camera format item */
        @Parcelize
        data class SensorDesc(val title: String, val cameraId: String, val format: Int) : Parcelable
    
        /** Helper function used to convert a lens orientation enum into a human-readable string */
        private fun lensOrientationString(value: Int) = when (value) {
            CameraCharacteristics.LENS_FACING_BACK -> "Back"
            CameraCharacteristics.LENS_FACING_FRONT -> "Front"
            CameraCharacteristics.LENS_FACING_EXTERNAL -> "External"
            else -> "Unknown"
        }
    
        /** Helper function used to list all compatible cameras and supported pixel formats */
    
        fun getCapStringAtIndex(index: Int): String {
            val strings = listOf(
                "BACKWARD_COMPATIBLE",
                "MANUAL_SENSOR",
                "MANUAL_POST_PROCESSING",
                "RAW",
                "PRIVATE_REPROCESSING",
                "READ_SENSOR_SETTINGS",
                "BURST_CAPTURE",
                "YUV_REPROCESSING",
                "DEPTH_OUTPUT",
                "CONSTRAINED_HIGH_SPEED_VIDEO",
                "MOTION_TRACKING",
                "LOGICAL_MULTI_CAMERA",
                "MONOCHROME",
                "SECURE_IMAGE_DATA",
                "SYSTEM_CAMERA",
                "OFFLINE_PROCESSING",
                "ULTRA_HIGH_RESOLUTION_SENSOR",
                "REMOSAIC_REPROCESSING",
                "DYNAMIC_RANGE_TEN_BIT",
                "STREAM_USE_CASE",
                "COLOR_SPACE_PROFILES"
            )
    
            if (index in 0 until strings.size) {
                return strings[index]
            } else {
                return "Invalid index"
            }
        }
    
        @SuppressLint("InlinedApi")
        fun enumerateCameras(cameraManager: CameraManager): List<SensorDesc> {
            val availableCameras: MutableList<SensorDesc> = mutableListOf()
    
            // Get list of all compatible cameras
            val cameraIds = mutableListOf<String>()
    
            for (i in 0..100) {
    
                val istr = i.toString()
                if (!cameraIds.contains(istr)) {
                    cameraIds.add(istr)
                }
            }
    
            val cameraIds2 = mutableListOf<String>()
            cameraIds.filter {
    
                try {
                    val characteristics = cameraManager.getCameraCharacteristics(it)
                    val capabilities = characteristics.get(
                        CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES
                    )
    
                    if (capabilities == null) {
                        false
                    } else if (capabilities.contains(
                            CameraMetadata.REQUEST_AVAILABLE_CAPABILITIES_LOGICAL_MULTI_CAMERA
                        )
                    ) {
                        false
                    } else if (capabilities.contains(
                            CameraMetadata.REQUEST_AVAILABLE_CAPABILITIES_BACKWARD_COMPATIBLE
                        )
                    ) {
                        true
                    } else {
                        false
                    }
    
    
                } catch (e: Exception) {
                    false
                }
            }.forEach { cameraIds2.add(it) }
    
    
            // Iterate over the list of cameras and return all the compatible ones
            cameraIds2.forEach { id ->
    
                Log.i("SELECTOR", "id: " + id)
                val characteristics = cameraManager.getCameraCharacteristics(id)
                val orientation = lensOrientationString(
                    characteristics.get(CameraCharacteristics.LENS_FACING)!!
                )
    
                // Query the available capabilities and output formats
                val capabilities = characteristics.get(
                    CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES
                )!!
    
                capabilities.forEach { Log.i("CAP", "" + getCapStringAtIndex(it)) }
    
    
                val outputFormats = characteristics.get(
                    CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP
                )!!.outputFormats
    
                val outputSizes = characteristics.get(
                    CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP
                )!!.getOutputSizes(ImageFormat.JPEG)
    
    
                val foaclmm = characteristics.get(
                    CameraCharacteristics.LENS_INFO_AVAILABLE_FOCAL_LENGTHS
                )!![0]
                val foc = ("" + foaclmm + "mm").padEnd(6, ' ')
                val ape = ("f" + characteristics.get(
                    CameraCharacteristics.LENS_INFO_AVAILABLE_APERTURES
                )!![0] + "").padEnd(4, ' ')
    
                val sensorSize = characteristics.get(
                    CameraCharacteristics.SENSOR_INFO_PHYSICAL_SIZE
                )!!
    
                val vfov =(( 2.0*(180.0 / 3.141592) * atan(sensorSize.height / (2.0 * foaclmm))).roundToInt().toString()+"°").padEnd(4,' ')
    
                // All cameras *must* support JPEG output so we don't need to check characteristics
    
                val title=  "vfov:$vfov $foc $ape $orientation"
                if(!availableCameras.any {it-> it.title==title } ){
                    availableCameras.add(
                        SensorDesc(
                            title, id, ImageFormat.JPEG
                        )
                    )
                }
    
    
    
            }
    
            return availableCameras
        }
    }


================================================================================
FICHIER : \AndroidStudioProjects\RemoteCam-Enhanced\app\src\main\java\com\samsung\android\scan3d\util\SettingsManager.kt
================================================================================
    package com.samsung.android.scan3d.util
    
    import android.content.Context
    import android.content.SharedPreferences
    import androidx.core.content.edit
    import com.samsung.android.scan3d.ViewState
    
    object SettingsManager {
    
        private const val PREFS_NAME = "RemoteCamSettings"
    
    // =========================================================
    // ============== PREFERENCE KEYS ==========================
    // =========================================================
    
        // --- ViewState Keys ---
        private const val KEY_PREVIEW = "preview"
        private const val KEY_STREAM = "stream"
        private const val KEY_CAMERA_ID = "cameraId"
        private const val KEY_RESOLUTION_INDEX = "resolutionIndex"
        private const val KEY_QUALITY = "quality"
        private const val KEY_FLASH = "flash_enabled"
        private const val KEY_ZOOM_RATIO = "zoom_ratio"
    
        // --- General Keys ---
        private const val KEY_THEME = "theme_mode"
        private const val KEY_MONET = "monet_enabled"
        private const val KEY_KEEP_SCREEN_ON = "keep_screen_on"
        private const val KEY_LANGUAGE = "language_code"
    
        // --- Remember Settings Keys ---
        private const val KEY_REMEMBER_SETTINGS_ENABLED = "remember_settings"
        private const val KEY_REMEMBER_FLASH = "remember_flash"
        private const val KEY_REMEMBER_ZOOM = "remember_zoom"
        private const val KEY_REMEMBER_SENSOR = "remember_sensor"
        private const val KEY_REMEMBER_RESOLUTION = "remember_resolution"
        private const val KEY_REMEMBER_QUALITY = "remember_quality"
    
        // --- Advanced Keys ---
        private const val KEY_TARGET_FPS = "target_fps"
        private const val KEY_DOUBLE_TAP_ACTION = "double_tap_action"
        private const val KEY_STABILIZATION_OFF = "stabilization_off"
        private const val KEY_ANTI_FLICKER_MODE = "anti_flicker_mode"
        private const val KEY_NOISE_REDUCTION_MODE = "noise_reduction_mode"
    
        // --- Controls Key ---
        private const val KEY_VOLUME_ACTION = "volume_action"
    
        // --- (NEW) Power and Screen Keys ---
        // KEY_IGNORE_OPTIMIZATIONS removed
        private const val KEY_AUTO_DIM_DELAY = "auto_dim_delay"
        private const val KEY_LOCK_INPUT_ON_DIM = "lock_input_on_dim"
        private const val KEY_BACKGROUND_STREAMING = "background_streaming"
        private const val KEY_ALLOW_RECONNECTS = "allow_reconnects"
    
        // --- (NEW) Zoom Smoothing Key ---
        private const val KEY_ZOOM_SMOOTHING_DELAY = "zoom_smoothing_delay"
    
        // --- (NEW) Network Key ---
        private const val KEY_HTTP_PORT = "http_port"
    
    
    // =========================================================
    // ============== CONSTANTS ================================
    // =========================================================
    
        // --- Theme Constants ---
        const val THEME_AUTO = 0
        const val THEME_LIGHT = 1
        const val THEME_DARK = 2
    
        // --- Language Constants ---
        const val LANG_AUTO = "auto"
        const val LANG_EN = "en"
        const val LANG_FR = "fr"
        const val LANG_HU = "hu"
        const val LANG_PT = "pt"
    
        // --- Action Constants ---
        const val DOUBLE_TAP_OFF = 0
        const val DOUBLE_TAP_SWITCH_CAM = 1
        const val DOUBLE_TAP_TOGGLE_ZOOM = 2
    
        // --- Advanced Constants ---
        const val ANTI_FLICKER_AUTO = 0
        const val ANTI_FLICKER_OFF = 1
        const val ANTI_FLICKER_50HZ = 2
        const val ANTI_FLICKER_60HZ = 3
    
        const val NR_AUTO = 0
        const val NR_OFF = 1
        const val NR_LOW = 2
        const val NR_HIGH = 3
    
        // --- NEW CONSTANTS (Controls) ---
        const val VOL_ACTION_OFF = 0
        const val VOL_ACTION_ZOOM = 1
        const val VOL_ACTION_SWITCH_CAM = 2
        const val VOL_ACTION_TOGGLE_FLASH = 3
    
        const val DIM_DELAY_OFF = 0
        const val DIM_DELAY_45S = 45000
        const val DIM_DELAY_1M = 60000
        const val DIM_DELAY_90S = 90000
        const val DIM_DELAY_2M = 120000
        const val DIM_DELAY_3M = 180000
        const val DIM_DELAY_5M = 300000
    
        const val SMOOTH_DELAY_NONE = 0
        const val SMOOTH_DELAY_5 = 5
        const val SMOOTH_DELAY_8 = 8
        const val SMOOTH_DELAY_10 = 10
        const val SMOOTH_DELAY_15 = 15
        const val SMOOTH_DELAY_20 = 20
        const val SMOOTH_DELAY_25 = 25
        const val SMOOTH_DELAY_30 = 30
        const val SMOOTH_DELAY_40 = 40
        const val SMOOTH_DELAY_50 = 50
    
        // --- (NEW) Network Constant ---
        const val DEFAULT_PORT = 8080
    
        private fun getPrefs(context: Context): SharedPreferences {
            return context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
        }
    
        /**
         * Saves the camera settings state (ViewState)
         * Called on every change in CameraScreen (via sendViewState)
         */
        fun saveSettings(context: Context, viewState: ViewState) {
            val rememberSettings = loadRememberSettings(context)
    
            getPrefs(context).edit {
                // Only saves if "Remember Settings" is enabled
                if (rememberSettings) {
                    putBoolean(KEY_PREVIEW, viewState.preview)
                    putBoolean(KEY_STREAM, viewState.stream)
    
                    if (loadRememberSensor(context)) {
                        putString(KEY_CAMERA_ID, viewState.cameraId)
                    }
                    if (loadRememberResolution(context)) {
                        putInt(KEY_RESOLUTION_INDEX, viewState.resolutionIndex ?: -1)
                    }
                    if (loadRememberQuality(context)) {
                        putInt(KEY_QUALITY, viewState.quality)
                    }
                    if (loadRememberFlash(context)) {
                        putBoolean(KEY_FLASH, viewState.flash)
                    }
                    // Zoom is handled by its own saveZoomRatio function
                }
            }
        }
    
        /**
         * Loads the camera settings state (ViewState)
         * Called when CameraScreen starts.
         */
        fun loadViewState(context: Context, defaultCameraId: String): ViewState {
            val prefs = getPrefs(context)
            val rememberSettings = loadRememberSettings(context)
    
            // Default values (used if "rememberSettings" is disabled)
            val defaultPreview = true
            val defaultStream = false
            val defaultQuality = 80
            val defaultFlash = false
    
            val preview = if (rememberSettings) prefs.getBoolean(KEY_PREVIEW, defaultPreview) else defaultPreview
            val stream = if (rememberSettings) prefs.getBoolean(KEY_STREAM, defaultStream) else defaultStream
    
            val cameraId = if (rememberSettings && loadRememberSensor(context)) {
                prefs.getString(KEY_CAMERA_ID, defaultCameraId)!!
            } else {
                defaultCameraId
            }
    
            val quality = if (rememberSettings && loadRememberQuality(context)) {
                prefs.getInt(KEY_QUALITY, defaultQuality)
            } else {
                defaultQuality
            }
    
            val resolutionIndexInt = if (rememberSettings && loadRememberResolution(context)) {
                prefs.getInt(KEY_RESOLUTION_INDEX, -1)
            } else {
                -1
            }
            val resolutionIndex = if (resolutionIndexInt == -1) null else resolutionIndexInt
    
            val flash = if (rememberSettings && loadRememberFlash(context)) {
                prefs.getBoolean(KEY_FLASH, defaultFlash)
            } else {
                defaultFlash
            }
    
            return ViewState(
                preview = preview,
                stream = stream,
                cameraId = cameraId,
                resolutionIndex = resolutionIndex,
                quality = quality,
                flash = flash
            )
        }
    
        // --- Theme & Appearance Functions ---
        fun saveThemeMode(context: Context, mode: Int) {
            getPrefs(context).edit { putInt(KEY_THEME, mode) }
        }
        fun loadThemeMode(context: Context): Int {
            return getPrefs(context).getInt(KEY_THEME, THEME_AUTO)
        }
        fun saveMonetEnabled(context: Context, enabled: Boolean) {
            getPrefs(context).edit { putBoolean(KEY_MONET, enabled) }
        }
        fun loadMonetEnabled(context: Context): Boolean {
            return getPrefs(context).getBoolean(KEY_MONET, true)
        }
        fun saveKeepScreenOn(context: Context, enabled: Boolean) {
            getPrefs(context).edit { putBoolean(KEY_KEEP_SCREEN_ON, enabled) }
        }
        fun loadKeepScreenOn(context: Context): Boolean {
            return getPrefs(context).getBoolean(KEY_KEEP_SCREEN_ON, false)
        }
    
        // --- Language Functions ---
        fun saveLanguage(context: Context, languageCode: String) {
            getPrefs(context).edit { putString(KEY_LANGUAGE, languageCode) }
        }
        fun loadLanguage(context: Context): String {
            return getPrefs(context).getString(KEY_LANGUAGE, LANG_AUTO) ?: LANG_AUTO
        }
    
        // --- Camera Functions (Remember Flags) ---
        fun saveRememberSettings(context: Context, enabled: Boolean) {
            getPrefs(context).edit { putBoolean(KEY_REMEMBER_SETTINGS_ENABLED, enabled) }
        }
        fun loadRememberSettings(context: Context): Boolean {
            return getPrefs(context).getBoolean(KEY_REMEMBER_SETTINGS_ENABLED, true)
        }
        fun saveRememberFlash(context: Context, enabled: Boolean) {
            getPrefs(context).edit { putBoolean(KEY_REMEMBER_FLASH, enabled) }
        }
        fun loadRememberFlash(context: Context): Boolean {
            return getPrefs(context).getBoolean(KEY_REMEMBER_FLASH, true)
        }
        fun saveRememberZoom(context: Context, enabled: Boolean) {
            getPrefs(context).edit { putBoolean(KEY_REMEMBER_ZOOM, enabled) }
        }
        fun loadRememberZoom(context: Context): Boolean {
            return getPrefs(context).getBoolean(KEY_REMEMBER_ZOOM, true)
        }
        fun saveRememberSensor(context: Context, enabled: Boolean) {
            getPrefs(context).edit { putBoolean(KEY_REMEMBER_SENSOR, enabled) }
        }
        fun loadRememberSensor(context: Context): Boolean {
            return getPrefs(context).getBoolean(KEY_REMEMBER_SENSOR, true)
        }
        fun saveRememberResolution(context: Context, enabled: Boolean) {
            getPrefs(context).edit { putBoolean(KEY_REMEMBER_RESOLUTION, enabled) }
        }
        fun loadRememberResolution(context: Context): Boolean {
            return getPrefs(context).getBoolean(KEY_REMEMBER_RESOLUTION, true)
        }
        fun saveRememberQuality(context: Context, enabled: Boolean) {
            getPrefs(context).edit { putBoolean(KEY_REMEMBER_QUALITY, enabled) }
        }
        fun loadRememberQuality(context: Context): Boolean {
            return getPrefs(context).getBoolean(KEY_REMEMBER_QUALITY, true)
        }
    
        // --- Functions for current values (Zoom/Exposure) ---
        fun saveZoomRatio(context: Context, ratio: Float) {
            if(loadRememberSettings(context) && loadRememberZoom(context)) {
                getPrefs(context).edit { putFloat(KEY_ZOOM_RATIO, ratio) }
            }
        }
        fun loadZoomRatio(context: Context): Float {
            if(loadRememberSettings(context) && loadRememberZoom(context)) {
                return getPrefs(context).getFloat(KEY_ZOOM_RATIO, 1.0f)
            }
            return 1.0f
        }
    // --- End Zoom/Exposure ---
    
        fun saveTargetFps(context: Context, fps: Int) {
            getPrefs(context).edit { putInt(KEY_TARGET_FPS, fps) }
        }
        fun loadTargetFps(context: Context): Int {
            return getPrefs(context).getInt(KEY_TARGET_FPS, 30)
        }
        fun saveDoubleTapAction(context: Context, action: Int) {
            getPrefs(context).edit { putInt(KEY_DOUBLE_TAP_ACTION, action) }
        }
        fun loadDoubleTapAction(context: Context): Int {
            return getPrefs(context).getInt(KEY_DOUBLE_TAP_ACTION, DOUBLE_TAP_OFF)
        }
    
        // --- Advanced Functions ---
        fun saveStabilizationOff(context: Context, enabled: Boolean) {
            getPrefs(context).edit { putBoolean(KEY_STABILIZATION_OFF, enabled) }
        }
        fun loadStabilizationOff(context: Context): Boolean {
            return getPrefs(context).getBoolean(KEY_STABILIZATION_OFF, false)
        }
        fun saveAntiFlickerMode(context: Context, mode: Int) {
            getPrefs(context).edit { putInt(KEY_ANTI_FLICKER_MODE, mode) }
        }
        fun loadAntiFlickerMode(context: Context): Int {
            return getPrefs(context).getInt(KEY_ANTI_FLICKER_MODE, ANTI_FLICKER_AUTO)
        }
        fun saveNoiseReductionMode(context: Context, mode: Int) {
            getPrefs(context).edit { putInt(KEY_NOISE_REDUCTION_MODE, mode) }
        }
        fun loadNoiseReductionMode(context: Context): Int {
            return getPrefs(context).getInt(KEY_NOISE_REDUCTION_MODE, NR_AUTO)
        }
    
        // --- Control Functions (UPDATED) ---
        fun saveVolumeAction(context: Context, action: Int) {
            getPrefs(context).edit { putInt(KEY_VOLUME_ACTION, action) }
        }
        fun loadVolumeAction(context: Context): Int {
            // Defaults to "OFF" (Disabled)
            return getPrefs(context).getInt(KEY_VOLUME_ACTION, VOL_ACTION_OFF)
        }
    
    // --- (NEW) Power and Screen Functions ---
    
        fun saveAutoDimDelay(context: Context, delayMs: Int) {
            getPrefs(context).edit { putInt(KEY_AUTO_DIM_DELAY, delayMs) }
        }
        fun loadAutoDimDelay(context: Context): Int {
            // Defaults to "Off" (0)
            return getPrefs(context).getInt(KEY_AUTO_DIM_DELAY, DIM_DELAY_OFF)
        }
    
        fun saveLockInputOnDim(context: Context, enabled: Boolean) {
            getPrefs(context).edit { putBoolean(KEY_LOCK_INPUT_ON_DIM, enabled) }
        }
        fun loadLockInputOnDim(context: Context): Boolean {
            return getPrefs(context).getBoolean(KEY_LOCK_INPUT_ON_DIM, false)
        }
    
        fun saveBackgroundStreaming(context: Context, enabled: Boolean) {
            getPrefs(context).edit { putBoolean(KEY_BACKGROUND_STREAMING, enabled) }
        }
        fun loadBackgroundStreaming(context:Context): Boolean {
            // Enabled by default
            return getPrefs(context).getBoolean(KEY_BACKGROUND_STREAMING, true)
        }
    
        fun saveAllowReconnects(context: Context, enabled: Boolean) {
            getPrefs(context).edit { putBoolean(KEY_ALLOW_RECONNECTS, enabled) }
        }
        fun loadAllowReconnects(context: Context): Boolean {
            // Enabled by default (as the fix will be applied)
            return getPrefs(context).getBoolean(KEY_ALLOW_RECONNECTS, true)
        }
        // --- (NEW) Zoom Smoothing Functions ---
        fun saveZoomSmoothingDelay(context: Context, delayMs: Int) {
            getPrefs(context).edit { putInt(KEY_ZOOM_SMOOTHING_DELAY, delayMs) }
        }
        fun loadZoomSmoothingDelay(context: Context): Int {
            // Defaults to "None" (0ms)
            return getPrefs(context).getInt(KEY_ZOOM_SMOOTHING_DELAY, SMOOTH_DELAY_NONE)
        }
    
        // --- (NEW) Network Functions ---
        fun savePort(context: Context, port: Int) {
            getPrefs(context).edit { putInt(KEY_HTTP_PORT, port) }
        }
        fun loadPort(context: Context): Int {
            return getPrefs(context).getInt(KEY_HTTP_PORT, DEFAULT_PORT)
        }
    }
    


================================================================================
FICHIER : \AndroidStudioProjects\RemoteCam-Enhanced\app\src\main\java\com\samsung\android\scan3d\AppNavigation.kt
================================================================================
    package com.samsung.android.scan3d
    
    import androidx.compose.animation.fadeIn
    import androidx.compose.animation.fadeOut
    import androidx.compose.animation.scaleOut
    import androidx.compose.animation.slideInHorizontally
    import androidx.compose.animation.slideOutHorizontally
    import androidx.compose.foundation.layout.fillMaxSize
    import androidx.compose.runtime.Composable
    import androidx.compose.ui.Modifier
    import androidx.navigation.compose.NavHost
    import androidx.navigation.compose.composable
    import androidx.navigation.compose.rememberNavController
    import com.samsung.android.scan3d.screens.AdditionalSettingsScreen
    import com.samsung.android.scan3d.screens.CameraScreen
    import com.samsung.android.scan3d.screens.PermissionScreen
    import com.samsung.android.scan3d.screens.SettingsScreen
    import com.samsung.android.scan3d.screens.PowerSettingsScreen
    
    sealed class Screen(val route: String) {
        object Permissions : Screen("permissions_screen")
        object Camera : Screen("camera_screen")
        object Settings : Screen("settings_screen")
        object AdditionalSettings : Screen("additional_settings_screen")
        object PowerSettings : Screen("power_settings_screen")
    }
    
    @Composable
    fun AppNavigation(
        cameraActivity: CameraActivity,
        startDestination: String,
        isInputLocked: Boolean
    ) {
        val navController = rememberNavController()
    
        NavHost(
            navController = navController,
            startDestination = startDestination,
            modifier = Modifier.fillMaxSize()
        ) {
            // Application des animations style "SukiSU Ultra" pour chaque écran
    
            composable(
                route = Screen.Permissions.route,
                enterTransition = { slideInHorizontally(initialOffsetX = { it }) },
                exitTransition = { slideOutHorizontally(targetOffsetX = { -it / 4 }) + fadeOut() },
                popEnterTransition = { slideInHorizontally(initialOffsetX = { -it / 4 }) + fadeIn() },
                popExitTransition = { scaleOut(targetScale = 0.9f) + fadeOut() }
            ) {
                PermissionScreen(
                    onNavigateToCamera = {
                        navController.navigate(Screen.Camera.route) {
                            popUpTo(Screen.Permissions.route) { inclusive = true }
                        }
                    },
                    onServiceStart = { cameraActivity.startCamService() }
                )
            }
    
            composable(
                route = Screen.Camera.route,
                // La caméra est souvent l'écran principal, on garde les mêmes anims pour la cohérence
                enterTransition = { slideInHorizontally(initialOffsetX = { it }) },
                exitTransition = { slideOutHorizontally(targetOffsetX = { -it / 4 }) + fadeOut() },
                popEnterTransition = { slideInHorizontally(initialOffsetX = { -it / 4 }) + fadeIn() },
                popExitTransition = { scaleOut(targetScale = 0.9f) + fadeOut() }
            ) {
                CameraScreen(
                    cameraActivity = cameraActivity,
                    onNavigateToSettings = { navController.navigate(Screen.Settings.route) },
                    isInputLocked = isInputLocked
                )
            }
    
            composable(
                route = Screen.Settings.route,
                enterTransition = { slideInHorizontally(initialOffsetX = { it }) },
                exitTransition = { slideOutHorizontally(targetOffsetX = { -it / 4 }) + fadeOut() },
                popEnterTransition = { slideInHorizontally(initialOffsetX = { -it / 4 }) + fadeIn() },
                popExitTransition = { scaleOut(targetScale = 0.9f) + fadeOut() }
            ) {
                SettingsScreen(
                    onBackClicked = { navController.popBackStack() },
                    onNavigateToAdditionalSettings = { navController.navigate(Screen.AdditionalSettings.route) },
                    onNavigateToPowerSettings = { navController.navigate(Screen.PowerSettings.route) }
                )
            }
    
            composable(
                route = Screen.AdditionalSettings.route,
                enterTransition = { slideInHorizontally(initialOffsetX = { it }) },
                exitTransition = { slideOutHorizontally(targetOffsetX = { -it / 4 }) + fadeOut() },
                popEnterTransition = { slideInHorizontally(initialOffsetX = { -it / 4 }) + fadeIn() },
                popExitTransition = { scaleOut(targetScale = 0.9f) + fadeOut() }
            ) {
                AdditionalSettingsScreen(
                    onBackClicked = { navController.popBackStack() }
                )
            }
    
            composable(
                route = Screen.PowerSettings.route,
                enterTransition = { slideInHorizontally(initialOffsetX = { it }) },
                exitTransition = { slideOutHorizontally(targetOffsetX = { -it / 4 }) + fadeOut() },
                popEnterTransition = { slideInHorizontally(initialOffsetX = { -it / 4 }) + fadeIn() },
                popExitTransition = { scaleOut(targetScale = 0.9f) + fadeOut() }
            ) {
                PowerSettingsScreen(
                    onBackClicked = { navController.popBackStack() }
                )
            }
        }
    }
    


================================================================================
FICHIER : \AndroidStudioProjects\RemoteCam-Enhanced\app\src\main\java\com\samsung\android\scan3d\CameraActivity.kt
================================================================================
    // File: app/src/main/java/com/samsung/android/scan3d/CameraActivity.kt
    
    package com.samsung.android.scan3d
    
    import android.Manifest
    import android.content.Intent
    import android.content.pm.PackageManager
    import android.os.Bundle
    import androidx.activity.compose.setContent
    import androidx.appcompat.app.AppCompatActivity
    import androidx.appcompat.app.AppCompatDelegate
    import androidx.core.content.ContextCompat
    import androidx.core.os.LocaleListCompat
    import androidx.core.view.WindowCompat
    import android.view.KeyEvent
    import com.samsung.android.scan3d.serv.Cam
    import com.samsung.android.scan3d.ui.theme.RemoteCamM3Theme
    import com.samsung.android.scan3d.util.SettingsManager
    import android.content.Context
    import android.os.Handler
    import android.os.Looper
    import androidx.compose.foundation.background
    import androidx.compose.foundation.clickable
    import androidx.compose.foundation.interaction.MutableInteractionSource
    import androidx.compose.foundation.layout.Box
    import androidx.compose.foundation.layout.fillMaxSize
    import androidx.compose.foundation.layout.padding
    import androidx.compose.material3.Text
    import androidx.compose.runtime.*
    import androidx.compose.ui.Alignment
    import androidx.compose.ui.Modifier
    import androidx.compose.ui.graphics.Color
    import androidx.compose.ui.res.stringResource
    import androidx.compose.ui.text.font.FontWeight
    import androidx.compose.ui.text.style.TextAlign
    import androidx.compose.ui.unit.dp
    import androidx.compose.ui.unit.sp
    import android.content.BroadcastReceiver
    import android.content.IntentFilter
    
    class CameraActivity : AppCompatActivity() {
    
        @Volatile
        var isRestarting: Boolean = false
    
        // --- (NEW) Variables for Power and Screen ---
        private var isInputLocked by mutableStateOf(false)
        private var isScreenDimmed = false
        private val dimHandler = Handler(Looper.getMainLooper())
        private var dimRunnable: Runnable? = null
        private var originalBrightness: Float = -1.0f // -1.0f is the system default value
    
        private val killReceiver = object : BroadcastReceiver() {
            override fun onReceive(context: Context?, intent: Intent?) {
                if (intent?.action == "KILL_ACTIVITY") {
                    finishAndRemoveTask()
                }
            }
        }
    
        /**
         * Checks if essential permissions are already granted.
         */
        private fun arePermissionsGranted(): Boolean {
            val permissions =
                listOf(Manifest.permission.CAMERA, Manifest.permission.POST_NOTIFICATIONS)
    
            return permissions.all {
                ContextCompat.checkSelfPermission(this, it) == PackageManager.PERMISSION_GRANTED
            }
        }
    
        /**
         * Starts the main camera service.
         * This function is called by AppNavigation
         */
        fun startCamService() {
            sendCam { it.action = "start" }
        }
    
        override fun onCreate(savedInstanceState: Bundle?) {
    
            // --- START OF LANGUAGE FIX ---
            val langCode = SettingsManager.loadLanguage(this)
            val appLocale: LocaleListCompat = if (langCode == SettingsManager.LANG_AUTO) {
                LocaleListCompat.getEmptyLocaleList()
            } else {
                LocaleListCompat.forLanguageTags(langCode)
            }
            AppCompatDelegate.setApplicationLocales(appLocale)
            // --- END OF LANGUAGE FIX ---
    
            super.onCreate(savedInstanceState)
            WindowCompat.setDecorFitsSystemWindows(window, false)
    
            originalBrightness = window.attributes.screenBrightness
    
            val startDestination = if (arePermissionsGranted()) {
                startCamService()
                Screen.Camera.route
            } else {
                Screen.Permissions.route
            }
    
            val filter = IntentFilter("KILL_ACTIVITY")
            registerReceiver(killReceiver, filter, RECEIVER_NOT_EXPORTED)
    
            setContent {
                RemoteCamM3Theme {
                    Box(Modifier.fillMaxSize()) {
                        AppNavigation(
                            cameraActivity = this@CameraActivity,
                            startDestination = startDestination,
                            isInputLocked = isInputLocked
                        )
    
                        // --- (NEW) Lock Overlay ---
                        if (isInputLocked) {
                            Box(
                                modifier = Modifier
                                    .fillMaxSize()
                                    .background(Color.Black.copy(alpha = 0.6f))
                                    .clickable(
                                        onClick = { resetDimTimer() }, // Unlocks on click
                                        indication = null,
                                        interactionSource = remember { MutableInteractionSource() }
                                    ),
                                contentAlignment = Alignment.Center
                            ) {
                                Text(
                                    text = stringResource(R.string.cam_overlay_locked),
                                    color = Color.White,
                                    fontSize = 18.sp,
                                    fontWeight = FontWeight.Bold,
                                    textAlign = TextAlign.Center,
                                    modifier = Modifier.padding(32.dp)
                                )
                            }
                        }
                    }
                }
            }
        }
    
        fun sendCam(callback: (intent: Intent) -> Unit) {
            val intent = Intent(this, Cam::class.java)
            callback(intent)
            startService(intent)
        }
    
        // --- (NEW) Dimming/Locking management functions ---
        private fun setScreenBrightness(value: Float) {
            val layoutParams = window.attributes
            layoutParams.screenBrightness = value
            window.attributes = layoutParams
        }
    
        private fun dimScreen() {
            setScreenBrightness(0.01f) // 1% brightness
            isScreenDimmed = true
            if (SettingsManager.loadLockInputOnDim(this)) {
                isInputLocked = true // Triggers the Compose overlay
            }
        }
    
        fun resetDimTimer() {
            stopDimTimer()
    
            if (isScreenDimmed) {
                setScreenBrightness(originalBrightness) // Restore brightness
                isScreenDimmed = false
                isInputLocked = false // Disables the overlay
            }
    
            val delay = SettingsManager.loadAutoDimDelay(this)
            if (delay > 0) {
                dimRunnable = Runnable { dimScreen() }
                dimHandler.postDelayed(dimRunnable!!, delay.toLong())
            }
        }
    
        private fun stopDimTimer() {
            dimRunnable?.let { dimHandler.removeCallbacks(it) }
            dimRunnable = null
        }
    
        // --- (NEW) Trigger the timer when the user touches the screen ---
        override fun onUserInteraction() {
            super.onUserInteraction()
            if (!isInputLocked) {
                resetDimTimer()
            }
        }
    
        // --- (NEW) Lifecycle for timers and WakeLock ---
        override fun onResume() {
            super.onResume()
            resetDimTimer()
            sendCam { it.action = "onResume" }
        }
    
        override fun onPause() {
            super.onPause()
            stopDimTimer()
            sendCam { it.action = "onPause" }
            // Don't release the WakeLock here, the service handles it
        }
    
        // --- onKeyDown FUNCTION (UPDATED) ---
        override fun onKeyDown(keyCode: Int, event: KeyEvent?): Boolean {
            if (isInputLocked) {
                return true
            }
            // Load the setting
            val action = SettingsManager.loadVolumeAction(this)
    
            // If the action is disabled, let the system handle it
            if (action == SettingsManager.VOL_ACTION_OFF) {
                return super.onKeyDown(keyCode, event)
            }
    
            when (keyCode) {
                KeyEvent.KEYCODE_VOLUME_UP -> {
                    when (action) {
                        SettingsManager.VOL_ACTION_ZOOM -> sendCam { it.action = "volume_zoom_in" }
                        SettingsManager.VOL_ACTION_SWITCH_CAM -> sendCam { it.action = "volume_action_switch_cam" }
                        SettingsManager.VOL_ACTION_TOGGLE_FLASH -> sendCam { it.action = "volume_action_toggle_flash" }
                    }
                    return true // Consume the event
                }
                KeyEvent.KEYCODE_VOLUME_DOWN -> {
                    when (action) {
                        SettingsManager.VOL_ACTION_ZOOM -> sendCam { it.action = "volume_zoom_out" }
                        // For "Switch Camera" and "Flash", do the same action for both buttons
                        SettingsManager.VOL_ACTION_SWITCH_CAM -> sendCam { it.action = "volume_action_switch_cam" }
                        SettingsManager.VOL_ACTION_TOGGLE_FLASH -> sendCam { it.action = "volume_action_toggle_flash" }
                    }
                    return true // Consume the event
                }
            }
    
            // If it's not a handled key, let the system handle it
            return super.onKeyDown(keyCode, event)
        }
        // --- END OF UPDATE ---
    
    
        override fun onDestroy() {
            unregisterReceiver(killReceiver)
            if (!isRestarting) {
                sendCam { it.action = "KILL" }
            }
            stopDimTimer()
            super.onDestroy()
        }
    }
    


================================================================================
FICHIER : \AndroidStudioProjects\RemoteCam-Enhanced\app\src\main\java\com\samsung\android\scan3d\CameraState.kt
================================================================================
    // app/src/main/java/com/samsung/android/scan3d/CameraState.kt
    
    package com.samsung.android.scan3d
    
    import android.os.Parcelable
    import kotlinx.parcelize.Parcelize
    
    @Parcelize
    data class ViewState(
        var preview: Boolean,
        var stream: Boolean,
        var cameraId: String,
        var resolutionIndex: Int?,
        var quality: Int,
        var flash: Boolean
    ) : Parcelable


================================================================================
FICHIER : \AndroidStudioProjects\RemoteCam-Enhanced\app\src\main\res\anim\nav_default_enter_anim.xml
================================================================================
    <?xml version="1.0" encoding="utf-8"?>
    <translate
        xmlns:android="http://schemas.android.com/apk/res/android"
        android:duration="@android:integer/config_shortAnimTime"
        android:fromXDelta="100%p"
        android:toXDelta="0" />
    


================================================================================
FICHIER : \AndroidStudioProjects\RemoteCam-Enhanced\app\src\main\res\anim\nav_default_exit_anim.xml
================================================================================
    <?xml version="1.0" encoding="utf-8"?>
    <translate
        xmlns:android="http://schemas.android.com/apk/res/android"
        android:duration="@android:integer/config_shortAnimTime"
        android:fromXDelta="0"
        android:toXDelta="-20%p" />


================================================================================
FICHIER : \AndroidStudioProjects\RemoteCam-Enhanced\app\src\main\res\anim\nav_default_pop_enter_anim.xml
================================================================================
    <?xml version="1.0" encoding="utf-8"?>
    <translate
        xmlns:android="http://schemas.android.com/apk/res/android"
        android:duration="@android:integer/config_shortAnimTime"
        android:fromXDelta="-20%p"
        android:toXDelta="0" />


================================================================================
FICHIER : \AndroidStudioProjects\RemoteCam-Enhanced\app\src\main\res\anim\nav_default_pop_exit_anim.xml
================================================================================
    <?xml version="1.0" encoding="utf-8"?>
    <translate
        xmlns:android="http://schemas.android.com/apk/res/android"
        android:duration="@android:integer/config_shortAnimTime"
        android:fromXDelta="0"
        android:toXDelta="100%p" />


================================================================================
FICHIER : \AndroidStudioProjects\RemoteCam-Enhanced\app\src\main\res\drawable\ic_launcher_background.xml
================================================================================
    <?xml version="1.0" encoding="utf-8"?>
    <vector
        android:height="108dp"
        android:width="108dp"
        android:viewportHeight="108"
        android:viewportWidth="108"
        xmlns:android="http://schemas.android.com/apk/res/android">
        <path android:fillColor="#3DDC84"
              android:pathData="M0,0h108v108h-108z"/>
        <path android:fillColor="#00000000" android:pathData="M9,0L9,108"
              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
        <path android:fillColor="#00000000" android:pathData="M19,0L19,108"
              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
        <path android:fillColor="#00000000" android:pathData="M29,0L29,108"
              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
        <path android:fillColor="#00000000" android:pathData="M39,0L39,108"
              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
        <path android:fillColor="#00000000" android:pathData="M49,0L49,108"
              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
        <path android:fillColor="#00000000" android:pathData="M59,0L59,108"
              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
        <path android:fillColor="#00000000" android:pathData="M69,0L69,108"
              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
        <path android:fillColor="#00000000" android:pathData="M79,0L79,108"
              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
        <path android:fillColor="#00000000" android:pathData="M89,0L89,108"
              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
        <path android:fillColor="#00000000" android:pathData="M99,0L99,108"
              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
        <path android:fillColor="#00000000" android:pathData="M0,9L108,9"
              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
        <path android:fillColor="#00000000" android:pathData="M0,19L108,19"
              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
        <path android:fillColor="#00000000" android:pathData="M0,29L108,29"
              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
        <path android:fillColor="#00000000" android:pathData="M0,39L108,39"
              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
        <path android:fillColor="#00000000" android:pathData="M0,49L108,49"
              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
        <path android:fillColor="#00000000" android:pathData="M0,59L108,59"
              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
        <path android:fillColor="#00000000" android:pathData="M0,69L108,69"
              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
        <path android:fillColor="#00000000" android:pathData="M0,79L108,79"
              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
        <path android:fillColor="#00000000" android:pathData="M0,89L108,89"
              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
        <path android:fillColor="#00000000" android:pathData="M0,99L108,99"
              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
        <path android:fillColor="#00000000" android:pathData="M19,29L89,29"
              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
        <path android:fillColor="#00000000" android:pathData="M19,39L89,39"
              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
        <path android:fillColor="#00000000" android:pathData="M19,49L89,49"
              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
        <path android:fillColor="#00000000" android:pathData="M19,59L89,59"
              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
        <path android:fillColor="#00000000" android:pathData="M19,69L89,69"
              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
        <path android:fillColor="#00000000" android:pathData="M19,79L89,79"
              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
        <path android:fillColor="#00000000" android:pathData="M29,19L29,89"
              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
        <path android:fillColor="#00000000" android:pathData="M39,19L39,89"
              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
        <path android:fillColor="#00000000" android:pathData="M49,19L49,89"
              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
        <path android:fillColor="#00000000" android:pathData="M59,19L59,89"
              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
        <path android:fillColor="#00000000" android:pathData="M69,19L69,89"
              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
        <path android:fillColor="#00000000" android:pathData="M79,19L79,89"
              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    </vector>
    


================================================================================
FICHIER : \AndroidStudioProjects\RemoteCam-Enhanced\app\src\main\res\drawable\ic_launcher_monochrome.xml
================================================================================
    <vector xmlns:android="http://schemas.android.com/apk/res/android"
        android:width="432dp"
        android:height="432dp"
        android:viewportWidth="432"
        android:viewportHeight="432">
      <path
          android:pathData="M160.56,293.78C158.6,290.98 158.58,287.43 160.5,282c0.82,-2.34 1.5,-4.87 1.5,-5.63C162,275.31 159.98,275 153.07,275c-8.76,0 -8.99,-0.06 -12.5,-3.37 -3.57,-3.37 -3.57,-3.37 -3.57,-59.25 0,-54.09 0.07,-55.99 2,-59.16 1.1,-1.8 3.15,-3.71 4.56,-4.25 1.46,-0.56 15.8,-0.98 33.42,-0.98 30.86,0 30.86,0 31.51,-2.97C209.17,141.96 214.12,137 216.5,137c2.37,0 7.33,4.96 8,7.99 0.64,2.93 0.64,2.93 33.16,3.22 32.51,0.29 32.51,0.29 35.43,3.55C296,155.03 296,155.03 296,211.65c0,56.62 0,56.62 -3.57,59.98 -3.51,3.31 -3.74,3.37 -12.5,3.37 -4.91,0 -8.93,0.38 -8.93,0.84 0,0.46 0.67,3.05 1.49,5.75 1.91,6.29 1.9,9.42 -0.05,12.19 -1.16,1.66 -2.56,2.22 -5.51,2.22 -3.39,0 -4.24,-0.46 -5.94,-3.25 -1.09,-1.79 -2.95,-6.18 -4.13,-9.75 -1.18,-3.58 -2.65,-6.83 -3.25,-7.23 -0.61,-0.4 -17.4,-0.74 -37.33,-0.75C180.05,275 180.05,275 178.64,277.25c-0.78,1.24 -2.14,4.5 -3.03,7.25 -0.89,2.75 -2.51,6.46 -3.6,8.25 -1.7,2.79 -2.55,3.25 -5.94,3.25 -2.96,0 -4.35,-0.56 -5.51,-2.22zM251.09,230.14C252.85,227.96 253,225.91 253,203.84c0,-23.93 0,-23.93 -2.45,-26.39C248.42,175.33 247.18,175 241.25,175c-6.67,0 -6.94,-0.1 -10.75,-4 -3.91,-4 -3.91,-4 -14,-4 -10.09,0 -10.09,0 -14,4 -3.82,3.91 -4.06,4 -10.89,4 -5.79,0 -7.38,0.37 -9.3,2.17C180.02,179.33 180,179.56 180,203.24c0,14.99 0.4,24.63 1.07,25.88 0.59,1.09 2.05,2.4 3.25,2.89 1.2,0.5 16.29,0.81 33.52,0.69 31.34,-0.21 31.34,-0.21 33.25,-2.57zM208.32,220.06c-2.63,-1.2 -5.23,-3.48 -7,-6.16C199.06,210.5 198.5,208.52 198.5,204c0,-4.49 0.57,-6.5 2.75,-9.8C204.63,189.09 210.38,186 216.5,186c6.12,0 11.87,3.09 15.25,8.2 2.19,3.3 2.75,5.32 2.75,9.8 0,4.52 -0.56,6.5 -2.82,9.9 -3.26,4.92 -9.16,8.05 -15.18,8.05 -2.2,0 -5.88,-0.85 -8.18,-1.9zM224.03,212.13c1.58,-1.58 3.18,-4.1 3.55,-5.59 0.38,-1.5 0.14,-4.52 -0.51,-6.71 -1,-3.34 -1.94,-4.32 -5.74,-6 -4.38,-1.94 -4.71,-1.95 -9.04,-0.29 -3.49,1.33 -4.83,2.51 -5.99,5.3 -2.09,5 -1.08,10.03 2.68,13.43 2.39,2.15 4.04,2.75 7.61,2.75 3.69,0 5.11,-0.55 7.43,-2.87z"
          android:fillColor="#000000"/>
    </vector>
    


================================================================================
FICHIER : \AndroidStudioProjects\RemoteCam-Enhanced\app\src\main\res\drawable\ic_photo.xml
================================================================================
    <?xml version="1.0" encoding="utf-8"?>
    <!--
      ~ Copyright 2020 The Android Open Source Project
      ~
      ~ Licensed under the Apache License, Version 2.0 (the "License");
      ~ you may not use this file except in compliance with the License.
      ~ You may obtain a copy of the License at
      ~
      ~     https://www.apache.org/licenses/LICENSE-2.0
      ~
      ~ Unless required by applicable law or agreed to in writing, software
      ~ distributed under the License is distributed on an "AS IS" BASIS,
      ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      ~ See the License for the specific language governing permissions and
      ~ limitations under the License.
      -->
    <vector xmlns:android="http://schemas.android.com/apk/res/android"
        android:width="24dp"
        android:height="24dp"
        android:viewportWidth="24.0"
        android:viewportHeight="24.0">
        <path
            android:fillColor="#000000"
            android:pathData="M21,19V5c0,-1.1 -0.9,-2 -2,-2H5c-1.1,0 -2,0.9 -2,2v14c0,1.1 0.9,2 2,2h14c1.1,0 2,-0.9 2,-2zM8.5,13.5l2.5,3.01L14.5,12l4.5,6H5l3.5,-4.5z"/>
    </vector>


================================================================================
FICHIER : \AndroidStudioProjects\RemoteCam-Enhanced\app\src\main\res\mipmap-anydpi-v26\ic_launcher.xml
================================================================================
    <?xml version="1.0" encoding="utf-8"?>
    <adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
        <background android:drawable="@color/ic_launcher_background"/>
        <foreground android:drawable="@mipmap/ic_launcher_foreground"/>
    
        <monochrome android:drawable="@drawable/ic_launcher_monochrome" />
    
    </adaptive-icon>
    


================================================================================
FICHIER : \AndroidStudioProjects\RemoteCam-Enhanced\app\src\main\res\mipmap-anydpi-v26\ic_launcher_round.xml
================================================================================
    <?xml version="1.0" encoding="utf-8"?>
    <adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
        <background android:drawable="@color/ic_launcher_background"/>
        <foreground android:drawable="@mipmap/ic_launcher_foreground"/>
    
        <monochrome android:drawable="@drawable/ic_launcher_monochrome" />
    
    </adaptive-icon>


================================================================================
FICHIER : \AndroidStudioProjects\RemoteCam-Enhanced\app\src\main\res\values\ic_launcher_background.xml
================================================================================
    <?xml version="1.0" encoding="utf-8"?>
    <resources>
        <color name="ic_launcher_background">#FFFFFF</color>
    </resources>


================================================================================
FICHIER : \AndroidStudioProjects\RemoteCam-Enhanced\app\src\main\res\values\strings.xml
================================================================================
    <resources>
        <!-- Notifications -->
        <string name="app_name">RemoteCam</string>
        <string name="notif_title">RemoteCam (active)</string>
        <string name="notif_text">Tap to open</string>
        <string name="notif_kill">Kill</string>
    
        <!-- Permissions Screen -->
        <string name="perm_welcome">Welcome to RemoteCam</string>
        <string name="perm_desc">To work, the app needs access to your camera and to show notifications.</string>
        <string name="perm_cam_reason">To capture and stream video.</string>
        <string name="perm_notif_reason">To keep the service active in the background.</string>
        <string name="perm_button">Grant permissions</string>
        <string name="perm_toast_denied">All permissions are required to use the application.</string>
        <string name="perm_welcome_title">Authorization Required</string>
        <string name="perm_reasons_title">Why these permissions?</string>
    
        <!-- Camera Screen -->
        <string name="cam_settings">Settings</string>
        <string name="cam_stop">STOP</string>
        <string name="cam_controls">Controls</string>
        <string name="cam_local_preview">Local preview</string>
        <string name="cam_mjpeg_stream">MJPEG Stream</string>
        <string name="cam_flash">Flashlight</string>
        <string name="cam_information">Information</string>
        <string name="cam_parameters">Parameters</string>
        <string name="cam_sensor">Sensor</string>
        <string name="cam_resolution">Resolution</string>
        <string name="cam_quality">JPEG Quality</string>
        <string name="cam_clipboard_copied">Copied to clipboard</string>
    
        <!-- Settings Screen: General -->
        <string name="settings_title">Settings</string>
        <string name="settings_back">Back</string>
        <string name="settings_appearance">Appearance</string>
        <string name="settings_theme">Theme</string>
        <string name="settings_theme_auto">Automatic (System)</string>
        <string name="settings_theme_light">Light</string>
        <string name="settings_theme_dark">Dark</string>
        <string name="settings_monet">Dynamic Color (Monet)</string>
        <string name="settings_behavior_title">Behavior</string>
        <string name="settings_keep_screen_on">Keep screen on</string>
        <string name="settings_language">Language</string>
        <string name="settings_lang_auto">Automatic (System)</string>
        <string name="settings_lang_en">English</string>
        <string name="settings_lang_fr">Français (French)</string>
        <string name="settings_lang_hu">Magyar (Hungarian)</string>
        <string name="settings_lang_pt_br">Português (Portuguese)</string>
        <string name="settings_additional_title">Additional Settings</string>
        <string name="settings_app_title">Application</string>
        <string name="settings_about_app">Application</string>
        <string name="settings_about_title">About RemoteCam</string>
        <string name="settings_close">Close</string>
        <string name="settings_save">Save</string>
    
        <!-- Settings Screen: Camera -->
        <string name="settings_camera_title">Camera</string>
        <string name="settings_remember_title">Remember camera settings</string>
        <string name="settings_remember_desc">Applies saved settings on startup</string>
        <string name="settings_remember_dialog_title">Remember...</string>
        <string name="settings_remember_flash">Flash state</string>
        <string name="settings_remember_zoom">Zoom level</string>
        <string name="settings_remember_sensor">Camera Sensor</string>
        <string name="settings_remember_resolution">Resolution</string>
        <string name="settings_remember_quality">JPEG Quality</string>
        <string name="settings_fps_title">Target FPS</string>
        <string name="settings_stabilization_title">Disable Stabilization (OIS/EIS)</string>
        <string name="settings_stabilization_desc">Improves latency on a tripod</string>
        <string name="settings_flicker_title">Anti-Flicker</string>
        <string name="settings_flicker_auto">Auto</string>
        <string name="settings_flicker_off">Off</string>
        <string name="settings_flicker_50hz">50Hz (Europe, Asia)</string>
        <string name="settings_flicker_60hz">60Hz (North America)</string>
        <string name="settings_noise_reduction_title">Noise Reduction</string>
        <string name="settings_noise_reduction_auto">Auto</string>
        <string name="settings_noise_reduction_off">Off</string>
        <string name="settings_noise_reduction_low">Low (Fast)</string>
        <string name="settings_noise_reduction_high">High (High Quality)</string>
    
        <!-- Settings Screen: Controls -->
        <string name="settings_controls_title">Controls</string>
        <string name="settings_double_tap_title">Double-tap action</string>
        <string name="settings_double_tap_off">Off</string>
        <string name="settings_double_tap_switch_cam">Switch camera</string>
        <string name="settings_double_tap_toggle_zoom">Toggle 2x zoom</string>
        <string name="settings_volume_action_title">Volume key action</string>
        <string name="settings_volume_action_off">Do nothing</string>
        <string name="settings_volume_action_zoom">Control zoom</string>
        <string name="settings_volume_action_switch_cam">Switch camera</string>
        <string name="settings_volume_action_toggle_flash">Toggle flashlight</string>
    
        <!-- About & Easter Egg -->
        <string name="about_fork">This application is an improved fork, maintained by @alananassss.</string>
        <string name="about_star">Star the repo on GitHub</string>
        <string name="about_telegram">Feel free to contact me on Telegram for any suggestions: @alananassss</string>
        <string name="about_version">Version %s</string>
        <string name="egg_title_alan">A little note from the dev :p</string>
        <string name="egg_message_alan">Hey there! Alan here ^^\n\nFunny that you clicked 7 times to get here!\n\nJust wanted to say thanks. This app is a \'fork\', which means I took the awesome base from the original dev and spent a ton of time adding my own improvements (days and days, evenings and weekends...).\n\nI really hope you find it useful!\n\nThanks for using it!\n- Alan</string>
        <string name="egg_button_alan">Cool! Greetings!</string>
    
        <string name="settings_power_title">Power and Screen</string>
        <string name="settings_power_ignore_optimizations">Ignore battery optimizations</string>
        <string name="settings_power_ignore_optimizations_desc">Bypass power-saving features (opens system settings)</string>
        <string name="settings_power_auto_dim">Auto dim screen</string>
        <string name="settings_power_auto_dim_dialog_title">Dim screen after...</string>
        <string name="settings_power_auto_dim_off">Off</string>
        <string name="settings_power_auto_dim_45s">45 seconds</string>
        <string name="settings_power_auto_dim_1m">1 minute</string>
        <string name="settings_power_auto_dim_90s">90 seconds</string>
        <string name="settings_power_auto_dim_2m">2 minutes</string>
        <string name="settings_power_auto_dim_3m">3 minutes</string>
        <string name="settings_power_auto_dim_5m">5 minutes</string>
        <string name="settings_power_lock_input">Lock input when dimmed</string>
        <string name="settings_power_lock_input_desc">Prevents accidental input</string>
        <string name="settings_power_background_streaming">Background streaming</string>
        <string name="settings_power_background_streaming_desc">Keep service active when app is in background</string>
        <string name="settings_power_allow_reconnects">Allow reconnects</string>
        <string name="settings_power_allow_reconnects_desc">Allows clients to reconnect to the stream</string>
        <string name="cam_overlay_locked">Screen dimmed and locked. Tap to unlock.</string>
    
        <string name="settings_remote_control_title">Remote Control</string>
        <string name="settings_zoom_smoothing_title">Zoom Smoothing</string>
        <string name="settings_zoom_smoothing_desc">Smooths out zoom changes from volume keys and double-tap</string>
        <string name="settings_zoom_smoothing_dialog_title">Smoothing Delay</string>
        <string name="settings_zoom_smoothing_none">None (Instant)</string>
    
        <string name="settings_network_title">Network</string>
        <string name="settings_port_title">HTTP Port</string>
        <string name="settings_port_summary">Port used by the MJPEG stream.</string>
        <string name="settings_port_dialog_title">Set HTTP Port</string>
        <string name="settings_port_dialog_label">Port (1025-65535)</string>
        <string name="settings_port_dialog_invalid">Invalid port. Must be between 1025 and 65535.</string>
    
    </resources>
    


================================================================================
FICHIER : \AndroidStudioProjects\RemoteCam-Enhanced\app\src\main\res\values\styles.xml
================================================================================
    <?xml version="1.0" encoding="utf-8"?>
    <resources>
        <style name="AppTheme" parent="Theme.Material3.DayNight.NoActionBar">
    
            <item name="android:statusBarColor">@android:color/transparent</item>
            <item name="android:navigationBarColor">@android:color/transparent</item>
    
            <item name="android:windowLightStatusBar">?android:attr/isLightTheme</item>
        </style>
    </resources>
    


================================================================================
FICHIER : \AndroidStudioProjects\RemoteCam-Enhanced\app\src\main\res\values-fr\strings.xml
================================================================================
    <resources>
        <!-- Notifications -->
        <string name="app_name">RemoteCam</string>
        <string name="notif_title">RemoteCam (actif)</string>
        <string name="notif_text">Appuyer pour ouvrir</string>
        <string name="notif_kill">Arrêter</string>
    
        <!-- Écran des permissions -->
        <string name="perm_welcome">Bienvenue sur RemoteCam</string>
        <string name="perm_desc">Pour fonctionner, l\'application a besoin d\'accéder à votre caméra et d\'afficher des notifications.</string>
        <string name="perm_cam_reason">Pour capturer et diffuser la vidéo.</string>
        <string name="perm_notif_reason">Pour maintenir le service actif en arrière-plan.</string>
        <string name="perm_button">Accorder les autorisations</string>
        <string name="perm_toast_denied">Toutes les autorisations sont requises pour utiliser l\'application.</string>
        <string name="perm_welcome_title">Autorisation requise</string>
        <string name="perm_reasons_title">Pourquoi ces autorisations ?</string>
    
        <!-- Écran Caméra -->
        <string name="cam_settings">Paramètres</string>
        <string name="cam_stop">STOP</string>
        <string name="cam_controls">Contrôles</string>
        <string name="cam_local_preview">Aperçu local</string>
        <string name="cam_mjpeg_stream">Flux MJPEG</string>
        <string name="cam_flash">Lampe torche</string>
        <string name="cam_information">Informations</string>
        <string name="cam_parameters">Paramètres</string>
        <string name="cam_sensor">Capteur</string>
        <string name="cam_resolution">Résolution</string>
        <string name="cam_quality">Qualité JPEG</string>
        <string name="cam_clipboard_copied">Copié dans le presse-papiers</string>
    
        <!-- Écran Paramètres: Général -->
        <string name="settings_title">Paramètres</string>
        <string name="settings_back">Retour</string>
        <string name="settings_appearance">Apparence</string>
        <string name="settings_theme">Thème</string>
        <string name="settings_theme_auto">Automatique (Système)</string>
        <string name="settings_theme_light">Clair</string>
        <string name="settings_theme_dark">Sombre</string>
        <string name="settings_monet">Couleur dynamique (Monet)</string>
        <string name="settings_behavior_title">Comportement</string>
        <string name="settings_keep_screen_on">Garder l\'écran allumé</string>
        <string name="settings_language">Langue</string>
        <string name="settings_lang_auto">Automatique (Système)</string>
        <string name="settings_lang_en">English (Anglais)</string>
        <string name="settings_lang_fr">Français</string>
        <string name="settings_lang_hu">Magyar (Hongrois)</string>
        <string name="settings_lang_pt_br">Português (Portugais)</string>
        <string name="settings_additional_title">Paramètres supplémentaires</string>
        <string name="settings_app_title">Application</string>
        <string name="settings_about_app">Application</string>
        <string name="settings_about_title">À propos de RemoteCam</string>
        <string name="settings_close">Fermer</string>
        <string name="settings_save">Enregistrer</string>
    
        <!-- Écran Paramètres: Caméra -->
        <string name="settings_camera_title">Caméra</string>
        <string name="settings_remember_title">Mémoriser les paramètres</string>
        <string name="settings_remember_desc">Applique les paramètres enregistrés au démarrage</string>
        <string name="settings_remember_dialog_title">Mémoriser...</string>
        <string name="settings_remember_flash">État de la lampe torche</string>
        <string name="settings_remember_zoom">Niveau de zoom</string>
        <string name="settings_remember_sensor">Capteur de la caméra</string>
        <string name="settings_remember_resolution">Résolution</string>
        <string name="settings_remember_quality">Qualité JPEG</string>
        <string name="settings_fps_title">IPS Cible</string>
        <string name="settings_stabilization_title">Désactiver la stabilisation (OIS/EIS)</string>
        <string name="settings_stabilization_desc">Améliore la latence sur trépied</string>
        <string name="settings_flicker_title">Anti-scintillement</string>
        <string name="settings_flicker_auto">Auto</string>
        <string name="settings_flicker_off">Désactivé</string>
        <string name="settings_flicker_50hz">50Hz (Europe, Asie)</string>
        <string name="settings_flicker_60hz">60Hz (Amérique du Nord)</string>
        <string name="settings_noise_reduction_title">Réduction du bruit</string>
        <string name="settings_noise_reduction_auto">Auto</string>
        <string name="settings_noise_reduction_off">Désactivé</string>
        <string name="settings_noise_reduction_low">Faible (Rapide)</string>
        <string name="settings_noise_reduction_high">Élevée (Haute Qualité)</string>
    
        <!-- Écran Paramètres: Contrôles -->
        <string name="settings_controls_title">Contrôles</string>
        <string name="settings_double_tap_title">Action du double-appui</string>
        <string name="settings_double_tap_off">Désactivé</string>
        <string name="settings_double_tap_switch_cam">Changer de caméra</string>
        <string name="settings_double_tap_toggle_zoom">Activer/désactiver le zoom x2</string>
        <string name="settings_volume_action_title">Action des touches de volume</string>
        <string name="settings_volume_action_off">Ne rien faire</string>
        <string name="settings_volume_action_zoom">Contrôler le zoom</string>
        <string name="settings_volume_action_switch_cam">Changer de caméra</string>
        <string name="settings_volume_action_toggle_flash">Activer/désactiver la lampe torche</string>
    
        <!-- "À propos" et Easter Egg -->
        <string name="about_fork">Cette application est un fork amélioré, maintenu par @alananassss.</string>
        <string name="about_star">Star le repo sur GitHub</string>
        <string name="about_telegram">N\'hésitez pas à me contacter sur Telegram pour toute suggestion : @alananassss</string>
        <string name="about_version">Version %s</string>
        <string name="egg_title_alan">Une petite note du dev :p</string>
        <string name="egg_message_alan">Salut ! C\'est Alan ^^\n\nC\'est drôle que tu aies cliqué 7 fois ici !\n\nJe voulais juste te dire merci. Cette app est un \'fork\', ce qui veut dire que j\'ai repris la super base du développeur original et que j\'y ai passé un temps fou (des jours et des jours, soirs et week-ends...) pour l\'améliorer à ma façon.\n\nJ\'espère vraiment qu\'elle te sert !\n\nMerci de l\'utiliser !\n- Alan</string>
        <string name="egg_button_alan">Cool ! Salutations !</string>
    
        <string name="settings_power_title">Énergie et Écran</string>
        <string name="settings_power_ignore_optimizations">Ignorer les optimisations batterie</string>
        <string name="settings_power_ignore_optimizations_desc">Contourne les restrictions d\'énergie (ouvre les paramètres)</string>
        <string name="settings_power_auto_dim">Assombrir l\'écran auto.</string>
        <string name="settings_power_auto_dim_dialog_title">Assombrir l\'écran après...</string>
        <string name="settings_power_auto_dim_off">Désactivé</string>
        <string name="settings_power_auto_dim_45s">45 secondes</string>
        <string name="settings_power_auto_dim_1m">1 minute</string>
        <string name="settings_power_auto_dim_90s">90 secondes</string>
        <string name="settings_power_auto_dim_2m">2 minutes</string>
        <string name="settings_power_auto_dim_3m">3 minutes</string>
        <string name="settings_power_auto_dim_5m">5 minutes</string>
        <string name="settings_power_lock_input">Verrouiller au lieu d\'assombrir</string>
        <string name="settings_power_lock_input_desc">Empêche les appuis accidentels</string>
        <string name="settings_power_background_streaming">Streaming en arrière-plan</string>
        <string name="settings_power_background_streaming_desc">Garde le service actif lorsque l\'app est en fond</string>
        <string name="settings_power_allow_reconnects">Autoriser les reconnexions</string>
        <string name="settings_power_allow_reconnects_desc">Permet aux clients de se reconnecter au flux</string>
        <string name="cam_overlay_locked">Écran assombri et verrouillé. Appuyez pour déverrouiller.</string>
    
        <string name="settings_remote_control_title">Contrôle à distance</string>
        <string name="settings_zoom_smoothing_title">Lissage du zoom</string>
        <string name="settings_zoom_smoothing_desc">Adoucit les changements de zoom des touches de volume et double-appui</string>
        <string name="settings_zoom_smoothing_dialog_title">Délai de lissage</string>
        <string name="settings_zoom_smoothing_none">Aucun (Instantané)</string>
    
        <string name="settings_network_title">Réseau</string>
        <string name="settings_port_title">Port HTTP</string>
        <string name="settings_port_summary">Port utilisé par le flux MJPEG.</string>
        <string name="settings_port_dialog_title">Définir le Port HTTP</string>
        <string name="settings_port_dialog_label">Port (1025-65535)</string>
        <string name="settings_port_dialog_invalid">Port invalide. Doit être entre 1025 et 65535.</string>
    
    </resources>
    


================================================================================
FICHIER : \AndroidStudioProjects\RemoteCam-Enhanced\app\src\main\res\values-hu\strings.xml
================================================================================
    <?xml version="1.0" encoding="utf-8"?>
    <resources>
        <string name="app_name">RemoteCam</string>
        <string name="notif_title">RemoteCam (aktív)</string>
        <string name="notif_text">Koppintson a megnyitáshoz</string>
        <string name="notif_kill">Leállítás</string>
    
        <string name="perm_welcome">Üdvözli a RemoteCam alkalmazás</string>
        <string name="perm_desc">A működéshez az alkalmazásnak hozzá kell férnie a kamerához, és értesítéseket kell megjelenítenie.</string>
        <string name="perm_cam_reason">Videó rögzítéséhez és streameléséhez.</string>
        <string name="perm_notif_reason">A szolgáltatás aktívan tartásához a háttérben.</string>
        <string name="perm_button">Engedélyek megadása</string>
        <string name="perm_toast_denied">Az alkalmazás használatához minden engedély szükséges.</string>
        <string name="perm_welcome_title">Engedély szükséges</string>
        <string name="perm_reasons_title">Miért kellenek ezek az engedélyek?</string>
    
        <string name="cam_settings">Beállítások</string>
        <string name="cam_stop">STOP</string>
        <string name="cam_controls">Vezérlők</string>
        <string name="cam_local_preview">Helyi előnézet</string>
        <string name="cam_mjpeg_stream">MJPEG Stream</string>
        <string name="cam_flash">Vaku</string>
        <string name="cam_information">Információ</string>
        <string name="cam_parameters">Paraméterek</string>
        <string name="cam_sensor">Érzékelő</string>
        <string name="cam_resolution">Felbontás</string>
        <string name="cam_quality">JPEG minőség</string>
        <string name="cam_clipboard_copied">Vágólapra másolva</string>
    
        <string name="settings_title">Beállítások</string>
        <string name="settings_back">Vissza</string>
        <string name="settings_appearance">Megjelenés</string>
        <string name="settings_theme">Téma</string>
        <string name="settings_theme_auto">Automatikus (rendszer)</string>
        <string name="settings_theme_light">Világos</string>
        <string name="settings_theme_dark">Sötét</string>
        <string name="settings_monet">Dinamikus szín (Monet)</string>
    
        <string name="settings_behavior_title">Viselkedés</string>
        <string name="settings_keep_screen_on">Képernyő bekapcsolva tartása</string>
        <string name="settings_language">Nyelv</string>
        <string name="settings_lang_auto">Automatikus (rendszer)</string>
        <string name="settings_lang_en">English</string>
        <string name="settings_lang_fr">Français (French)</string>
        <string name="settings_lang_hu">Magyar</string>
        <string name="settings_lang_pt_br">Portugál (Portuguese)</string>
    
        <string name="settings_additional_title">További beállítások</string>
        <string name="settings_app_title">Alkalmazás</string>
        <string name="settings_about_app">Az alkalmazásról</string>
        <string name="settings_about_title">A RemoteCam névjegye</string>
        <string name="settings_close">Bezárás</string>
        <string name="settings_save">Mentés</string>
    
        <string name="settings_camera_title">Kamera</string>
        <string name="settings_remember_title">Kamerabeállítások megjegyzése</string>
        <string name="settings_remember_desc">Indításkor alkalmazza a mentett beállításokat</string>
        <string name="settings_remember_dialog_title">Megjegyzés...</string>
        <string name="settings_remember_flash">Vaku állapota</string>
        <string name="settings_remember_zoom">Zoom szint</string>
        <string name="settings_remember_sensor">Kameraérzékelő</string>
        <string name="settings_remember_resolution">Felbontás</string>
        <string name="settings_remember_quality">JPEG minőség</string>
        <string name="settings_fps_title">Cél FPS</string>
        <string name="settings_stabilization_title">Stabilizálás letiltása (OIS/EIS)</string>
        <string name="settings_stabilization_desc">Javítja a késleltetést állvány használatakor</string>
        <string name="settings_flicker_title">Villódzásgátló</string>
        <string name="settings_flicker_auto">Automatikus</string>
        <string name="settings_flicker_off">Ki</string>
        <string name="settings_flicker_50hz">50Hz (Európa, Ázsia)</string>
        <string name="settings_flicker_60hz">60Hz (Észak-Amerika)</string>
    
        <string name="settings_noise_reduction_title">Zajcsökkentés</string>
        <string name="settings_noise_reduction_auto">Automatikus</string>
        <string name="settings_noise_reduction_off">Ki</string>
        <string name="settings_noise_reduction_low">Alacsony (gyors)</string>
        <string name="settings_noise_reduction_high">Magas (jobb minőség)</string>
    
        <string name="settings_controls_title">Vezérlők</string>
        <string name="settings_double_tap_title">Dupla koppintás művelete</string>
        <string name="settings_double_tap_off">Ki</string>
        <string name="settings_double_tap_switch_cam">Kameraváltás</string>
        <string name="settings_double_tap_toggle_zoom">2x zoom váltása</string>
        <string name="settings_volume_action_title">Hangerőgomb művelet</string>
        <string name="settings_volume_action_off">Nincs művelet</string>
        <string name="settings_volume_action_zoom">Zoom vezérlés</string>
        <string name="settings_volume_action_switch_cam">Kameraváltás</string>
        <string name="settings_volume_action_toggle_flash">Vaku váltása</string>
    
        <string name="about_fork">Ez az alkalmazás egy továbbfejlesztett fork, karbantartója: @alananassss.</string>
        <string name="about_star">Csillagozza a repót GitHubon</string>
        <string name="about_telegram">Keressen bátran Telegramon javaslatokkal: @alananassss</string>
        <string name="about_version">Verzió %s</string>
    
        <string name="egg_title_alan">Egy kis üzenet a fejlesztőtől :p</string>
        <string name="egg_message_alan">Szia! Alan vagyok ^^\n\nVicces, hogy hétszer koppintottál ide!\n\nCsak köszönetet akartam mondani. Ez az app egy „fork”, ami azt jelenti, hogy az eredeti fejlesztő fantasztikus alapját vettem, és rengeteg időt (napokat, estéket és hétvégéket...) töltöttem a saját fejlesztéseim hozzáadásával.\n\nNagyon remélem, hogy hasznosnak találod!\n\nKöszi, hogy használod!\n- Alan</string>
        <string name="egg_button_alan">Király! Üdv!</string>
    
        <string name="settings_power_title">Energia és képernyő</string>
        <string name="settings_power_ignore_optimizations">Akkumulátor-optimalizálás figyelmen kívül hagyása</string>
        <string name="settings_power_ignore_optimizations_desc">Energiatakarékos funkciók megkerülése (rendszerbeállításokat nyit meg)</string>
        <string name="settings_power_auto_dim">Képernyő automatikus sötétítése</string>
        <string name="settings_power_auto_dim_dialog_title">Képernyő sötétítése ennyi idő után...</string>
        <string name="settings_power_auto_dim_off">Ki</string>
        <string name="settings_power_auto_dim_45s">45 másodperc</string>
        <string name="settings_power_auto_dim_1m">1 perc</string>
        <string name="settings_power_auto_dim_90s">90 másodperc</string>
        <string name="settings_power_auto_dim_2m">2 perc</string>
        <string name="settings_power_auto_dim_3m">3 perc</string>
        <string name="settings_power_auto_dim_5m">5 perc</string>
        <string name="settings_power_lock_input">Bemenet zárolása sötétítéskor</string>
        <string name="settings_power_lock_input_desc">Megakadályozza a véletlen bevitelt</string>
        <string name="settings_power_background_streaming">Háttérben történő streamelés</string>
        <string name="settings_power_background_streaming_desc">A szolgáltatás aktívan tartása, ha az alkalmazás a háttérben van</string>
        <string name="settings_power_allow_reconnects">Újracsatlakozás engedélyezése</string>
        <string name="settings_power_allow_reconnects_desc">Lehetővé teszi a kliensek számára, hogy újracsatlakozzanak a streamhez</string>
        <string name="cam_overlay_locked">A képernyő elsötétítve és zárolva. Koppintson a feloldáshoz.</string>
    
        <string name="settings_remote_control_title">Távirányító</string>
        <string name="settings_zoom_smoothing_title">Zoom simítás</string>
        <string name="settings_zoom_smoothing_desc">Simítja a hangerőgombok és a dupla koppintás által végzett zoomváltozásokat</string>
        <string name="settings_zoom_smoothing_dialog_title">Simítási késleltetés</string>
        <string name="settings_zoom_smoothing_none">Nincs (azonnali)</string>
    
        <string name="settings_network_title">Hálózat</string>
        <string name="settings_port_title">HTTP-port</string>
        <string name="settings_port_summary">Az MJPEG stream által használt port.</string>
        <string name="settings_port_dialog_title">HTTP-port beállítása</string>
        <string name="settings_port_dialog_label">Port (1025–65535)</string>
        <string name="settings_port_dialog_invalid">Érvénytelen port. 1025 és 65535 között kell lennie.</string>
    </resources>
    


================================================================================
FICHIER : \AndroidStudioProjects\RemoteCam-Enhanced\app\src\main\res\values-pt-rBR\strings.xml
================================================================================
    <resources>
        <!-- Notificações -->
        <string name="app_name">RemoteCam</string>
        <string name="notif_title">RemoteCam (ativo)</string>
        <string name="notif_text">Toque para abrir</string>
        <string name="notif_kill">Fechar</string>
    
        <!-- Tela de Permissões -->
        <string name="perm_welcome">Bem-vindo(a) ao RemoteCam</string>
        <string name="perm_desc">Para funcionar, o app precisa do acesso à sua câmera e para exibir notificações.</string>
        <string name="perm_cam_reason">Para capturar e transmitir vídeo.</string>
        <string name="perm_notif_reason">Para manter o serviço ativo em segundo plano.</string>
        <string name="perm_button">Conceder permissões</string>
        <string name="perm_toast_denied">Todas as permissões são necessárias para usar o aplicativo.</string>
        <string name="perm_welcome_title">Autorização Necessária</string>
        <string name="perm_reasons_title">Por que essas permissões?</string>
    
        <!-- Tela da Câmera -->
        <string name="cam_settings">Configurações</string>
        <string name="cam_stop">PARAR</string>
        <string name="cam_controls">Controles</string>
        <string name="cam_local_preview">Prévia local</string>
        <string name="cam_mjpeg_stream">Transmissão em MJPEG</string>
        <string name="cam_flash">Lanterna</string>
        <string name="cam_information">Informação</string>
        <string name="cam_parameters">Parâmetros</string>
        <string name="cam_sensor">Sensor</string>
        <string name="cam_resolution">Resolução</string>
        <string name="cam_quality">Qualidade do JPEG</string>
        <string name="cam_clipboard_copied">Copiado para a área de transferência</string>
    
        <!-- Tela de Configurações: Geral -->
        <string name="settings_title">Configurações</string>
        <string name="settings_back">Voltar</string>
        <string name="settings_appearance">Aparência</string>
        <string name="settings_theme">Tema</string>
        <string name="settings_theme_auto">Automático (Sistema)</string>
        <string name="settings_theme_light">Claro</string>
        <string name="settings_theme_dark">Escuro</string>
        <string name="settings_monet">Cor Dinâmica (Monet)</string>
        <string name="settings_behavior_title">Comportamento</string>
        <string name="settings_keep_screen_on">Manter a tela ativa</string>
        <string name="settings_language">Idioma</string>
        <string name="settings_lang_auto">Automático (Sistema)</string>
        <string name="settings_lang_en">English (Inglês)</string>
        <string name="settings_lang_fr">Français (Francês)</string>
        <string name="settings_lang_hu">Magyar (Húngaro)</string>
        <string name="settings_lang_pt_br">Português (Brasileiro)</string>
        <string name="settings_additional_title">Configurações Adicionais</string>
        <string name="settings_app_title">Aplicativo</string>
        <string name="settings_about_app">Aplicativo</string>
        <string name="settings_about_title">Sobre o RemoteCam</string>
        <string name="settings_close">Fechar</string>
        <string name="settings_save">Salvar</string>
    
        <!-- Tela de Configurações: Câmera -->
        <string name="settings_camera_title">Câmera</string>
        <string name="settings_remember_title">Lembrar as configurações da câmera</string>
        <string name="settings_remember_desc">Aplica as configurações salvas na inicialização</string>
        <string name="settings_remember_dialog_title">Lembrar...</string>
        <string name="settings_remember_flash">Estado do flash</string>
        <string name="settings_remember_zoom">Nível do zoom</string>
        <string name="settings_remember_sensor">Sensor da Câmera</string>
        <string name="settings_remember_resolution">Resolução</string>
        <string name="settings_remember_quality">Qualidade do JPEG</string>
        <string name="settings_fps_title">FPS Alvo</string>
        <string name="settings_stabilization_title">Desabilitar estabilização (OIS/EIS)</string>
        <string name="settings_stabilization_desc">Melhora a latência em um tripé</string>
        <string name="settings_flicker_title">Anti-Flicker</string>
        <string name="settings_flicker_auto">Automático</string>
        <string name="settings_flicker_off">Desativado</string>
        <string name="settings_flicker_50hz">50Hz (Europa, Ásia)</string>
        <string name="settings_flicker_60hz">60Hz (América do Norte)</string>
        <string name="settings_noise_reduction_title">Redução de Ruído</string>
        <string name="settings_noise_reduction_auto">Automático</string>
        <string name="settings_noise_reduction_off">Desativado</string>
        <string name="settings_noise_reduction_low">Baixo (Rápido)</string>
        <string name="settings_noise_reduction_high">Alto (Alta Qualidade)</string>
    
        <!-- Tela de Configurações: Controles -->
        <string name="settings_controls_title">Controles</string>
        <string name="settings_double_tap_title">Ação ao toque duplo</string>
        <string name="settings_double_tap_off">Desativado</string>
        <string name="settings_double_tap_switch_cam">Trocar de câmera</string>
        <string name="settings_double_tap_toggle_zoom">Alternar o zoom em 2x</string>
        <string name="settings_volume_action_title">Ação aos botões de volume</string>
        <string name="settings_volume_action_off">Não fazer nada</string>
        <string name="settings_volume_action_zoom">Controlar o zoom</string>
        <string name="settings_volume_action_switch_cam">Trocar de câmera</string>
        <string name="settings_volume_action_toggle_flash">Alternar a lanterna</string>
    
        <!-- Sobre & Easter Egg -->
        <string name="about_fork">Este aplicativo é uma versão melhorada, mantido por @alananassss.</string>
        <string name="about_star">Dê uma estrela no GitHub</string>
        <string name="about_telegram">Fique à vontade para me contatar no Telegram para qualquer sugestão: @alananassss</string>
        <string name="about_version">Versão %s</string>
        <string name="egg_title_alan">Um pouquinho mais do dev :p</string>
        <string name="egg_message_alan">Olá! Alan aqui ^^\n\nEngraçado que você clicou 7 vezes para chegar aqui!\n\nApenas queria dizer obrigado. Este app é um \'fork\', que significa que eu peguei a base incrível do desenvolvedor original e gastei bastante tempo adicionando minhas próprias melhorias (dias e dias, noites e fins de semanas...).\n\nEspero sinceramente que você ache isso útil!\n\nObrigado por usar!\n- Alan</string>
        <string name="egg_button_alan">Legal! Saudações!</string>
    
        <string name="settings_power_title">Energia e Tela</string>
        <string name="settings_power_ignore_optimizations">Ignorar as otimizações de bateria</string>
        <string name="settings_power_ignore_optimizations_desc">Contornar as funções de economia de bateria (abre as configurações do sistema)</string>
        <string name="settings_power_auto_dim">Escurecer a tela automaticamente</string>
        <string name="settings_power_auto_dim_dialog_title">Escurecer a tela após...</string>
        <string name="settings_power_auto_dim_off">Desativado</string>
        <string name="settings_power_auto_dim_45s">45 segundos</string>
        <string name="settings_power_auto_dim_1m">1 minuto</string>
        <string name="settings_power_auto_dim_90s">90 segundos</string>
        <string name="settings_power_auto_dim_2m">2 minutos</string>
        <string name="settings_power_auto_dim_3m">3 minutos</string>
        <string name="settings_power_auto_dim_5m">5 minutos</string>
        <string name="settings_power_lock_input">Bloquear entrada quando a tela escurecer</string>
        <string name="settings_power_lock_input_desc">Impede toques acidentais</string>
        <string name="settings_power_background_streaming">Transmissão em segundo plano</string>
        <string name="settings_power_background_streaming_desc">Mantém o serviço ativo quando o app estiver em segundo plano</string>
        <string name="settings_power_allow_reconnects">Permitir reconexões</string>
        <string name="settings_power_allow_reconnects_desc">Permitir o cliente reconectar à transmissão</string>
        <string name="cam_overlay_locked">Tela escurecida e bloqueada. Toque para desbloquear.</string>
    
        <string name="settings_remote_control_title">Controle remoto</string>
        <string name="settings_zoom_smoothing_title">Suavização no Zoom</string>
        <string name="settings_zoom_smoothing_desc">Suaviza as mudanças no zoom das teclas de volume e do toque duplo</string>
        <string name="settings_zoom_smoothing_dialog_title">Atraso de Suavização</string>
        <string name="settings_zoom_smoothing_none">Nenhum (Instantâneo)</string>
    
        <string name="settings_network_title">Rede</string>
        <string name="settings_port_title">Porta HTTP</string>
        <string name="settings_port_summary">Porta usada pela transmissão MJPEG.</string>
        <string name="settings_port_dialog_title">Define uma porta HTTP</string>
        <string name="settings_port_dialog_label">Porta (1025-65535)</string>
        <string name="settings_port_dialog_invalid">Porta inválida. Precisa ser entre 1025 e 65535.</string>
    
    </resources>
    


================================================================================
FICHIER : \AndroidStudioProjects\RemoteCam-Enhanced\app\src\main\res\xml\backup_rules.xml
================================================================================
    <?xml version="1.0" encoding="utf-8"?>
    <full-backup-content>
        <include domain="file" path="."/>
        <include domain="database" path="."/>
        <include domain="sharedpref" path="."/>
        <include domain="external" path="."/>
    </full-backup-content>
    


================================================================================
FICHIER : \AndroidStudioProjects\RemoteCam-Enhanced\app\src\main\res\xml\data_extraction_rules.xml
================================================================================
    <?xml version="1.0" encoding="utf-8"?>
    <data-extraction-rules>
        <cloud-backup>
            <include domain="file" path="."/>
            <include domain="database" path="."/>
            <include domain="sharedpref" path="."/>
            <include domain="external" path="."/>
        </cloud-backup>
        <device-transfer>
            <include domain="file" path="."/>
            <include domain="database" path="."/>
            <include domain="sharedpref" path="."/>
            <include domain="external" path="."/>
        </device-transfer>
    </data-extraction-rules>
    


================================================================================
FICHIER : \AndroidStudioProjects\RemoteCam-Enhanced\app\src\main\AndroidManifest.xml
================================================================================
    <?xml version="1.0" encoding="UTF-8"?>
    <!--
      ~ Copyright 2020 The Android Open Source Project
      ~
      ~ Licensed under the Apache License, Version 2.0 (the "License");
      ~ you may not use this file except in compliance with the License.
      ~ You may obtain a copy of the License at
      ~
      ~     https://www.apache.org/licenses/LICENSE-2.0
      ~
      ~ Unless required by applicable law or agreed to in writing, software
      ~ distributed under the License is distributed on an "AS IS" BASIS,
      ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      ~ See the License for the specific language governing permissions and
      ~ limitations under the License.
      -->
    <manifest xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:tools="http://schemas.android.com/tools">
    
        <!-- Permission declarations -->
        <uses-permission android:name="android.permission.CAMERA" />
        <uses-permission android:name="android.permission.INTERNET" />
        <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
        <uses-permission android:name="android.permission.FOREGROUND_SERVICE_CAMERA" />
        <uses-permission android:name="android.permission.POST_NOTIFICATIONS" />
        <uses-permission android:name="android.permission.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS" />
        <uses-permission android:name="android.permission.VIBRATE" />
    
        <!-- Camera feature requirements -->
        <uses-feature android:name="android.hardware.camera.any" />
        <uses-feature
            android:name="android.hardware.camera.raw"
            android:required="false" />
    
        <application
            android:dataExtractionRules="@xml/data_extraction_rules"
            android:fullBackupContent="@xml/backup_rules"
            android:icon="@mipmap/ic_launcher"
            android:roundIcon="@mipmap/ic_launcher_round"
            android:label="@string/app_name"
            android:enableOnBackInvokedCallback="true"
            tools:ignore="GoogleAppIndexingWarning">
    
            <activity
                android:name="com.samsung.android.scan3d.CameraActivity"
                android:clearTaskOnLaunch="true"
                android:exported="true"
                android:launchMode="singleTask"
                android:theme="@style/AppTheme">
    
                <!-- Main app intent filter -->
                <intent-filter>
                    <action android:name="android.intent.action.MAIN" />
                    <category android:name="android.intent.category.LAUNCHER" />
                </intent-filter>
    
            </activity>
    
            <!-- Foreground service with camera type declaration for Android 14+ -->
            <service
                android:name="com.samsung.android.scan3d.serv.Cam"
                android:enabled="true"
                android:exported="true"
                android:foregroundServiceType="camera"
                android:permission="android.permission.FOREGROUND_SERVICE_CAMERA" />
    
        </application>
    
    </manifest>
    


